所有高级语言锁的实现都依赖操作系统底层的锁实现，操作系统层面上锁的实现机制有自旋锁(spinlock)和mutex两种。

# 自旋锁
自旋锁非阻塞锁，多个线程尝试获取自旋锁时，没有获取到的线程会持续尝试获取直到获取到为止。获取锁的操作大多使用CAS、TAS等硬件指令实现，比如Test and test-and-set模式自旋锁的实现:
```
boolean locked := false
procedure EnterCritical() {
  do {
    while (locked == true)
  } while TestAndSet(locked)
}
```
当然，实际实现中会做更多的tradeoff，更高效的实现需要考虑多核CPU的缓存一致性、锁变量更新时的总线开销、锁的公平性等问题

自旋锁不涉及到线程上下文切换，相对于mutex来说比较轻量，常用作高级语言的锁优化

但是因为没有获取到锁的线程会进入”忙等 “状态消耗CPU资源，如果获取到锁的线程持有锁的时间比较长，会对性能造成一定影响。所以，**自旋锁一般适用于线程持有锁的时间比较短，锁的获取和释放频繁的情况**

# mutex
mutex是阻塞锁，多个线程尝试获取锁时，没有获取到锁的线程会被操作系统调度为阻塞状态，直到锁被释放然后才会被重新唤醒

OS线程调度，线程上下文切换带来的开销是很大的，多线程程序如果有大量的线程切换，最坏情况下性能甚至会比单线程运行的代码效率还要差。mutex锁如果被频繁的获取和释放，代价也可想而知

spinlock比较高效，适用于线程持有锁时间短的情况，mutex适用于线程持有锁时间比较长的情况, 线程如果持有锁的时间很短带来的开销会很大。

实际应用上可以把这两种锁结合起来使用，称为adaptive mutex。获取锁的操作分两步，第一步使用spinlock获取，当尝试几次还是获取不到时，再执行mutex操作。glibc的futex操作就使用这种机制来提高性能。

其实无论是spinlock还是mutex，基于硬件指令的实现本身性能都是很高的。在应用层面需要注意的是尽量少的避免资源竞争，多线程之间大量的资源竞争无论是线程空转消耗CPU还是上下文频繁切换都会影响程序性能。

# 锁状态
## 死锁
死锁是已经进入等待状态的线程相互等待各自锁释放的一种循环等待的状态。如下图，线程1和线程2同时获取Lock1和Lock2才能运行，某个时刻，线程1拥有Lock1， 线程2拥有Lock2，各自又分别在等待Lock2和Lock1，从而进入死锁状态。死锁的本质是对资源的竞争导致，死锁可以被预防和检测。

## 活锁
活锁和死锁产生的条件一样，只是表现不同。死锁下线程进入等待状态，而活锁下线程仍然处于运行状态尝试获取锁。活锁下线程仍然消耗CPU，这样看来，活锁和死锁的区别也有点类似spinlock和mutex。

# 锁策略
锁的存在是为了保护临界资源，操作系统层面提供spinlock和mutex两种方式，需要考虑的是怎样实现以保证锁的高效。而应用层考虑的是如何更高效的使用他们, 使用什么样的策略去保护不同的临界资源。

## 独占锁
独占锁(exclusive lock)，有时候也被称为写锁，排它锁等。被独占锁保护的资源，同一时刻只能有一个线程可以进行读写操作。

## 共享锁
共享锁(shared lock)，有时候也被称为读锁。被共享锁保护的资源，当有线程写时仍然可以被别的线程读取，读线程数并不限定为1。但是同一时刻只能有一个线程写入


## 可重入锁
可重入锁可以并且只能被已经持有锁的线程加锁多次，一个线程内有多个地方形成对该锁的嵌套获取时可以防止死锁发生。实现上可重入锁会记录自己被lock的次数，只有unlock的次数和lock次数相等时才完成对锁的释放。

## 公平锁、非公平锁
公平锁顾名思义，申请锁的线程按照申请顺序来获取锁，遵循先申请先得到的原则。而非公平锁则没有该顺序保障。公平锁通常使用等待队列来实现，申请线程未获取到锁时则进入等待队列，锁被释放时得到通知或者直接由上个拥有者移交锁的所有权。

# 数据库系统
数据库系统中的锁用于事务控制，保证数据库的ACID特性，有乐观锁， 悲观锁和两段锁等。

## 乐观锁
乐观锁 是并发访问控制的一种模式，实际上并没有对任何资源加锁。乐观锁假定事务大部分情况下不会出现冲突，运行时不对资源加锁，而在commit时检测是否有冲突，发现有冲突时执行rollback并重启事务

资源竞争不激烈时采用乐观锁可以消除等待锁释放、加锁的开销，实现高吞吐量。资源竞争激列的情况下频繁的rollback和事务重启，效率会很差。 乐观锁通常采用给资源增加版本号的方式来实现。需要注意的是冲突检查和commit/rollback两个操作需要保证原子性，避免产生TOCTTOU问题，mysql上可以使用一个带条件的update语句实现比较和更新操作的原子性。

## 悲观锁
悲观锁假定冲突一定会发生，写操作直接对资源加独占锁，其他事务的写操作必须等待。读操作时，其他事务不能修改资源但是可读。悲观锁能有效的避免事务冲突，但是不会产生冲突的事务操作也需要加锁进行导致性能会比较差。

## 两段锁
数据库事务操作遵循两段锁协议来保证事务操作的串行化。两段锁协议分为两个阶段: a. 加锁阶段(Expanding phase), 只能获取锁，不能释放锁 b. 解锁阶段(Shrinking phase),修改数据然后释放锁，不能获取锁 参考:http://user.it.uu.se/~arnoldp/distrib/TwoPhase.html

