数据只有数组和链表两种存储方式，以数组和链表为基础衍生出其他结构

# 数组
数组是按照数据类型和数量分配的连续的内存，基址内存坐标+下标*数据类型大小，非常简单且基础的结构

数组一定是连续的内存区域。**如果数组所需的内存过大，在内存中找不到那么大的区域就可能会分配失败**，比如说快速排序需要在数组中处理，如果对几十亿数据做快排，是不可能在内存中找到这么大的连续内存，要考虑分而治之或其他算法

ps：1G内存能存储1.3亿个8字节数据

数组可以根据下表直接访问元素，但是删除和插入元素需要移动后面的元素，复杂度为O(n)

- 在特殊情况下，用位标识下标，可以解决一些问题
- 双指针能解决很多数组问题
- 在数组边界增加哨兵可以少考虑很多边界情况
- 多维数组的遍历

## 切片
现在很流行slice，许多编程语言都内置了该结构，使用也很方便，但要注意扩容时会消耗太多时间，且扩容时线程不安全

当扩容时需要遍历数组o(n)，但平均到每个append操作上只有o(1)，平均来看时间复杂度为o(1)，但扩容时有暂时的卡顿

# 链表
链表：多个节点相互关联的链，他的插入、删除高效，查找只能靠遍历

每次创建节点都需要系统调用内存分配(耗时1)，所以得到不连续的内存，无法利用cache的空间局部性(耗时2)，使用后还要被GC回收(耗时3)

在借助GC的语言中，如果对内存比较苛刻，那么使用链表应该是一件小心的事，确保被删除的节点不会有其他节点引用，避免内存泄露。同时，尽可能重用节点，太多节点的添加删除会给GC带来压力

- 双指针，块慢指针，前后指针，都是解决链表问题的好助手
- 在链表前后加上哨兵，可以减少很多特殊情况的考虑，记得最后要释放哨兵。哨兵也可以用于数组，当一个算法有特殊情况需要考虑，使得代码繁琐，不妨试试哨兵
- 对于链表的操作，要考虑很多边界情况，链表为空、只有一个节点、两个节点、头结点、尾节点等等

常见问题
- 单链表反转、链表中环的检测、两个有序的链表合并、删除链表倒数第n个结点、求链表的中间结点等

# 栈、队列
- 栈：先进后出
- 队列：先进先出

他们都可以基于数组或链表实现，如果pop和push相对稳定，可以使用数组，如果不稳定或不确定则用链表

