数据只有数组和链表两种存储方式，以数组和链表为基础衍生出其他结构

# 数组
数组是按照数据类型和数量分配的连续的内存，基址内存坐标+下标*数据类型大小，非常简单且基础的结构

数组一定是连续的内存区域。**如果数组所需的内存过大，在内存中找不到那么大的区域就可能会分配失败**，比如说快速排序需要在数组中处理，如果对几十亿数据做快排，是不可能在内存中找到这么大的连续内存，要考虑分而治之或其他算法

ps：1G内存能存储1.3亿个8字节数据

数组可以根据下表直接访问元素，但是删除和插入元素需要移动后面的元素，复杂度为O(n)
## 基础技能
- 双指针能解决很多数组问题
- 在数组边界增加哨兵可以少考虑很多边界情况
- 掌握多维数组的遍历，注意边界条件判断
- 在特殊情况下，用位标识下标，可以解决一些问题

## 切片
现在很流行slice，许多编程语言都内置了该结构，使用也很方便，但要注意扩容时会消耗太多时间，且扩容时线程不安全

当扩容时需要遍历数组o(n)，但平均到每个append操作上只有o(1)，平均来看时间复杂度为o(1)，但扩容时有暂时的卡顿

# 链表
链表：多个节点相互关联的链，他的插入、删除高效，查找只能靠遍历

每次创建节点都需要系统调用内存分配(耗时1)，所以得到不连续的内存，无法利用cache的空间局部性(耗时2)，使用后还要被GC回收(耗时3)

在借助GC的语言中，如果对内存比较苛刻，那么使用链表应该是一件小心的事，确保被删除的节点不会有其他节点引用，避免内存泄露。同时，尽可能重用节点，太多节点的添加删除会给GC带来压力

## 基础技能
- 双指针、前后指针、快慢指针找中间节点、反转链表、局部反转链表
- 在链表前后加上哨兵，可以减少很多特殊情况的考虑，记得最后要释放哨兵
- 对于链表的操作，要考虑很多边界情况，链表为空、只有一个节点、两个节点、头结点、尾节点等等
- 单链表反转、链表中环的检测、两个有序的链表合并、删除链表倒数第n个结点、求链表的中间结点等都是其他链表问题的基础

## 链表经典题目
```
// 反转left到right位置的链表
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    if head == nil || left < 1 || left >= right{
        return head
    }
    if left == 1 {
        return reverseN(head, right)
    }
    head.Next = reverseBetween(head.Next, left-1, right-1)
    return head
}

var successor *ListNode

func reverseN(head *ListNode, n int) *ListNode {
    if n == 1{
        successor = head.Next
        return head
    }

    latest := reverseN(head.Next, n-1)
    head.Next.Next = head
    head.Next = successor
    return latest
}
```

# 栈、队列
- 栈：先进后出
- 队列：先进先出

他们都可以基于数组或链表实现，如果pop和push相对稳定，可以使用数组，如果不稳定或不确定则用链表

