# hash算法
- 单向不可逆，只能从key推导出value，不能从value反向推导

# 散列函数
数组是一个很好的按key索引val的结构，但key只能是整数，还最好是连续的，散列表将key扩展倒更多的数据类型

散列表要做的第一件事就是将key通过散列函数转化为整数key，用于在数组中寻找val，但不可避免的发生key冲突，所以第二件事就是解决key冲突问题

第一个问题就是存入不同类型的key都要转为为一个整数值，我们需要为不同的类型制定不同的转化规则，并使转化后的key在一定的范围内索引

总的来说，要实现一个好的散列函数需要满足三个条件

- 一致性：相同的值应该生成相同的key
- 高效性：计算简单高效
- 均匀性：生成的key应该是在索引内均匀分布

# 处理碰撞
如果一个散列函数生成的值具有范围，当key大于值范围时一定会产生碰撞，即多个不同的key生成相同的值

## 拉链法
数组中的元素是一个链表，如果发生冲突，则作为节点保存在链表中，一些语言会将最新加入的节点保存在头部，便于查找

如果链表过长会降低查询速度，可以组织成树结构

## 开放地址法
开放地址法核心思想是利用空位解决冲突，最简单的例子，如果该位置已经存在值，那么向下偏移一位，这种方式不常用

# 应用
所有的语言都提供散列表结构，他是一个非常简单高效的查找结构，但在某些情况下查找性能并不好，考虑散列表插入和查询过程

- 计算hash值，取前几位或后几位作为数组下表
- 查询：查找数组存储元素，如果是链表逐个查询
- 插入：将值存放在数组元素链表头部，如果map容量超过容量因子，扩容，平均到每个元素上扩容操作为o(1)，所以插入操作是o(1)

真正耗时的是hash值计算所需时间，如果计算hash值时间等同于遍历length==1000的数组，那我们为什么不遍历查找呢。一般情况下低于100个元素，数组遍历的会更快些

散列表的查询结构非常简单，也可以延展做重复次数统计的工作，但结构过于简单也限制了扩展更丰富的功能，即使他和平衡树性能相近，在有复杂需求的场景下，更多的选择还是树结构

另一个问题是扩展带来的延迟，这对实时性要求较高的应用是致命的，也有些语言实现了增量扩容，避免了暂时性卡顿

散列表思想也常在分布式中应用，所有的机器组成了容纳数组，应用被hash计算分配到每个机器上

# 分布式hash
