在多核心+多线程并行运行场景下，对临界值的修改需要保证原子操作，如

- a = a + b，两个核心同时将获取到a b，且运行a+b值，最终运行两次只得到一次a+b
- 在32位机器上写入64位数据要分两次写，可能刚写完前一半就被其他线程获取，得到异常的值，struct更是分多步写入，多执行流并发读写相同全局变量时一定要小心，最好用atomic.Value

在这种场景下，必须保证并行情况下的正确性，即保证临界资源同时只有一个执行流访问，通常有两种方式

- 共享内存方式，对临界区加锁，拥有锁的执行流获取操作权限
- 流访问方式，通过channel控制只有一个执行流操作，不存在多个指令流并行问题

临界区加锁有两种方式实现
- 软件保障，如Peterson算法
- 硬件保障操作的原子性

atomic就是封装了操作系统提供的原子操作，都是硬件保障实现的，sync.Mutex也是在atomic基础上封装软件层面的锁



