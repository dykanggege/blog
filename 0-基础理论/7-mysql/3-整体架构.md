# 概览
![](imgs/1.png)

总的来说mysql可以分为 server 层和存储层

- server：所有跨存储引擎的功能都在server层实现，例如存储过程、触发器、视图等
- 存储层插件化实现，我们常用的是 innerDB，实现增删改查、事务、索引等功能


# 连接器
用于管理连接，权限验证，mysql 使用 tcp 作为连接协议

    mysql -h$ip -P$port -u$user -p

1. 用户名密码通过后会查你的权限，然后建立tcp长链接，权限在长连接中生效，所以修改权限并不能立刻生效，要用 flush privileges; 刷新权限

2. 连接后如果没有动作就是空闲连接，默认8小时没有动作自动断开，由 wait_timeout 参数控制

3. 如果全部使用长连接，可能会发现Mysql占用内存增长特别快，因为mysql在执行过程中临时使用的内存是管理在连接对象中的，连接断开后才会释放。5.7以后执行mysql_reset_connection重新初始化连接资源

4. 维持多个长连接，当客户端执行sql时从中拿出一个使用，用完就放回去，简称连接池，和线程池甚至云计算都一个原理

5. 并发量小情况下维持过多长连接只会浪费 mysql 宿主机的内存资源。而瞬时并发过高，如秒杀，长连接也救不了mysql，并发量相对稳定情况下最适合长连接

6. show processlist 可以查看所有的连接

## 缓存
连接建立后就可以执行select语句了，他会先查询缓存，之前执行的语句值会以 key-val 的形式存在内存中，但是发生update语句后就会被清除

如果频繁插入这样就会很耗费性能，除非这个表经常查询，很少更新，否则建议将参数 query_cache_type 设置成 DEMAN 关闭缓存查询

缓存查询这种事可以交给redis做，所以msyql8中直接将这一块删掉了
 
## 分析器、优化器
分析器是编译sql，其实这步可以在程序中做，少用动态sql，多用已经编译好的sql，提高性能

就像编译原理一样，优化器是不可靠的，尽量把sql写好，别指望优化器做什么

## 执行器
前面都做完了就开始执行，首先要判断一下有没有执行权限，然后调用引擎，返回执行的结果

# 存储层
存储层借助于存储引擎实现，mysql采用插件的方式使用存储引擎，主流的引擎有 InnerDB、MyISAM、Memory等，5.5.5版本以后使用InnerDB作为默认的存储引擎，后面也主讲解 InnerDB 

# log
mysql 运行中产生的 log 可分为三种

## error
错误日志会记录如下信息

- mysql执行过程中的错误信息
- mysql执行过程中的告警信息
- event scheduler运行时所产生信息
- mysq启动和停止过程中产生的信息
- 主从复制结构中，重从服务器IO复杂线程的启动信息

默认存放在 /var/log/mysqld.log 可在 my.cnf 用 log_error 配置

```
MariaDB [(none)]> show variables where
    -> variable_name="log_error" or
    -> variable_name="log_warnings";
+---------------+------------------------------------------------------+
| Variable_name | Value                                                |
+---------------+------------------------------------------------------+
| log_error     | /var/log/mysqld.log                                  |
| log_warnings  | 2                                                    |
+---------------+------------------------------------------------------+
2 rows in set (0.001 sec)
```

log_warnings：表示是否记录告警信息到错误日志，0表示不记录告警信息，1表示记录告警信息，大于1表示各类告警信息，例如有关网络故障的信息和重新连接信息写入错误日志


select好说，就是上面server执行的那些步骤，但是update可不一般

我们对update的期望不仅仅是更新，还要记录下日志便于出错回滚

    update T set c=c+1 where ID=2;

这个语句一旦执行，和T表相关的缓存全部失效，所以不建议使用缓存

同时还要记录两个日志，redo log 和 binlog 

## binlog
binlog是mysql服务层产生的日志，用于数据恢复、集群同步

binlog是逻辑日志，记录每个语句的原始逻辑，使用追加写，不会覆盖以前的日志

通常数据库会一周一备份或者每天备份，如果想回退到某个时间点A的状态，可以先找到A之前的备份，再执行备份到A之间的binlog


## redo log、undo log
当更新时，要先查找B+树(如果你用到索引的话)，再查找磁盘位置，更新磁盘，这是非常耗时的，如果在一个时间内并发量特别大，就崩了

linux写入文件时，可能会先放在内存中，空闲时写入磁盘，mysql也用了这个思路，先记录redo log，再更新在内存中，事务提交时进程flush操作，即WAL技术，Write-Ahead Logging，分布式系统中也可以利用WAL实现宽松一致性

redo log是顺序写入的，磁盘顺序写入速度远大于随机读写

当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性

InnerDB的redo log是固定大小的，如果配置一组为4个文件，每个文件大小是1G，总共就可以记录4G的操作，循环覆盖写入

![](imgs/2.png)

write pos指向已经写入磁盘的操作，check point是最新的操作，两者之间的绿色就是已经更新但还没写入磁盘

有了redo log，对内存的操作都不会丢失，就算服务挂了，内存cache数据全部丢失，还能用redo log恢复写入


## 总结

一个update执行的完整流程如下
 
![](imgs/3.png)


整个过程分为prepare和commit两个阶段，因为无论redo log还是binlog先完成，中间宕机，重新启动服务后都会有错误，他们必须是一个事务操作

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。
