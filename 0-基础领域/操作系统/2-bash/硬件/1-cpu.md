# CPU

- 响应时间：执行一段程序所需时间
- 性能：1/响应时间
- 吞吐率：单位时间内处理的事情，一般提高响应时间可提高吞吐率
- 时钟周期：1/2.8G，CPU指令执行速度以时钟周期为衡量
- 程序CPU时间：CPU时钟周期数 * 时钟周期
- CPU性能：f(晶体管密度，晶体管闭合速度)，提升工艺就是在提升密度
- 功耗：负载电容\*电压平方\*开关频率\*晶体管数量，降低电压可平方级降低功耗，但CPU性能也会收到影响

时钟周期由频率计算，频率越高周期越短，在相同指令集，cpu架构设计下，频率越高核心的性能越好，但发热会指数上涨，现在cpu厂商不会将频率固定在某个值，而是允许在范围内浮动

## 精简指令集

这种CPU 的设计中，微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单纯，指令的执行效能较佳； 但是若要做复杂的事情，就要由多个指令来完成。常见的RISC 微指令集CPU 主要例如甲骨文(Oracle) 公司的SPARC 系列、 IBM 公司的Power Architecture (包括PowerPC) 系列、与安谋公司(ARM Holdings) 的ARM CPU 系列等。

## 复杂指令集

与RISC不同的，CISC在微指令集的每个小指令可以执行一些较低阶的硬体操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。

由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人电脑(Personal computer)用途上面，因此，个人电脑常被称为x86架构的电脑！这是因为最早的那颗Intel发展出来的CPU代号称为8086，后来依此架构又开发出80286, 80386...，因此这种架构的CPU就被称为x86架构了。

在2003年以前由Intel所开发的x86架构CPU由8位元升级到16、32位元，后来AMD依此架构修改新一代的CPU为64位元， 为了区别两者的差异，因此64位元的个人电脑CPU又被统称为x86_64的架构喔！

## lscpu
查看cpu信息


```
Architecture:        x86_64 //x86_64 架构
CPU op-mode(s):      32-bit, 64-bit 
Byte Order:          Little Endian //小段
CPU(s):              8 //核心数目，其实是并行线程数，虚拟核心
On-line CPU(s) list: 0-7
Thread(s) per core:  2 //单核心超线程数量
Core(s) per socket:  4 //4核心
Socket(s):           1
NUMA node(s):        1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               142
Model name:          Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz
Stepping:            10
CPU MHz:             2774.810 //默认频率
CPU max MHz:         3400.0000  //建议最大频率
CPU min MHz:         400.0000
BogoMIPS:            3600.00
Virtualization:      VT-x //支持cpu虚拟化
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            6144K
NUMA node0 CPU(s):   0-7
```

在 /proc/cpuinfo 里可以看到每个核心更详细的信息

其实最好的办法还是知道cpu型号后Google


# 中断
中断是一种电信号，当设备有某种事情发生时，通过总线将电信号发给cpu，处理器跳到中断处理程序的处理点

中断源可分为两类
- 内部中断：即执行软件中断指令INT或遇到软件陷阱而产生的中断，它们的中断类型号已由CPU规定好
- IO硬件中断：硬件中断分为NMI不可屏蔽中断，INTR可屏蔽中断

## 硬中断
- 硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通常是内核中的一个子程序，而不是一个独立的进程）。

- 处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）。

- 硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可能被其他的硬中断中断。

- 对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让调度代码（或称为调度器）可以调度多任务。

## 软中断
软中断不会抢占另外的一个软中断，唯一可以抢占软中断的硬中断

为了满足实时系统的要求，中断处理应该越快越好。编写驱动程序的时候，一个中断产生之后，内核在中断处理函数中可能需要完成很多工作。但是中断处理函数的处理是关闭了中断的。也就是说在响应中断时，系统不能再次响应外部的其它中断。这样的后果会造成有可能丢失外部中断。于是，linux内核设计出了一种架构，中断函数需要处理的任务分为两部分，一部分在中断处理函数中执行，这时系统关闭中断。另外一部分在软件中断中执行，这个时候开启中断，系统可以响应外部中断。

Linux为了实现这个特点，当中断发生的时候硬中断处理那些短时间，就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。

- 软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的。

- 通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。对于某些设备，I/O请求需要被立即处理，而磁盘I/O请求通常可以排队并且可以稍后处理。根据I/O模型的不同，进程或许会被挂起直到I/O完成，此时内核调度器就会选择另一个进程去运行。I/O可以在进程之间产生并且调度过程通常和磁盘I/O的方式是相同。

- 软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行。

- 软中断并不会直接的中断CPU。也只有当前正在运行的代码(或者是进程)才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情(通常是I/O)的请求。有一个特殊的软中断是Yield调用，他的作用是请求内核调度器去查看是否有其他的进程可以运行。
