# 设计模式
所谓设计模式，就是留有余地

程序员编写代码的同时要为未来考虑，在编写一段代码后未来可能面临的场景如下

- 阅读代码，可读性，是其他的基础
    - 项目架构设计、分层简单清晰
    - 模块间功能边界明确、接口简单、高内敛低耦合
    - 函数大小合适，功能划分有层级感
    - 减少嵌套，逻辑代码配置化
    - 变量命名易懂、文档简练
- 项目需要持续有人维护，可维护性
    - 高内聚低耦合
    - 能够通过清晰的逻辑或debug日志快速定位bug
    - 局部的逻辑修改不会影响到其他地方
    - 修bug时不会引入新的bug
- 功能总是会变化增加的，扩展性
    - 对未来变化的考虑和预留接口
    - 清晰的接口设定，更容器在原有的基础上扩展新功能或需求变化时易修改
- 可复用性
    - 将小的功能抽象为随处可用的库
- 简洁性
    - 尽可能用简单的方式完成功能
- 可测试性
    - 容易编写高质量的测试

因为代码会面临以上的问题，就有人提出了新的编程范式，如面向对象编程，像堆积木一样写代码。也有其他的编程范式，每种编程范式都有自己适合的领域

在某种特定情况下解决上面问题有固定套路，总结出来就是设计模式

场景是多种多样的，设计模式只能解决某些场景，最核心的是体会在某种场景下解决上面需求的思路，即编程思想

# 设计原则
为了达到追求的目的，我们提出了各种手段和模式，归纳起来他们有着共同的原则，这些原则是指导思想，基于这些思想在特定场景下创建了模式

# 抽象和具体分离
- 基于抽象而非形象编程，将具体的和抽象的分离开
- 研究事物本身，分析其本质并建模，是所谓抽象编程

## 依赖倒置原则
**高层模块不应该依赖于底层模块，他们都应该依赖于抽象，即抽象不依赖细节，细节依赖与抽象**，这是实现开闭原则的基本手段

每个类都尽可能的提供抽象接口，其他模块使用时应该使用抽象类或接口，类的继承应该遵循里氏替换原则

## 里氏替换原则
**继承必须确保超类拥有的属性和功能在子类中仍然成立**，通俗的说，子类可以扩展父类的属性和功能，但不要覆盖和改变父类原有功能

里氏替换原则是对开闭原则的不同，它确保了动作的正确性，即类的扩展不会给系统引入错误，克服了重写父类带来的可用性变差的问题

## 接口隔离原则
**一个类对另一个类的依赖应该建立在最小接口上**，这是基本的封装原则，你应该暴露最高层的属性和方法，而不是什么都暴露出去，丧失了调用的可读性，调用者还容易瞎瘠薄调用

同时它的目的时尽可能减少类的职责，并降低类的颗粒度，增强可读性和复用性

# 最小原则
不要提供额外的负担或功能，只给予最小权限，也是对编辑器很好的利用

# 开闭原则

**软件应该对扩展开放，对修改关闭**：其含义是，当我们要对一个软件的功能做修改或扩展时，应该不修改之前的代码并扩展功能，以实现新的需求。其本质是**抽象约束，封装变化**

1. 这就需要架构师具有前瞻性，提前分析出软件中哪些是可变的，哪些是不可变的，甚至对每一部分都不相信，假设他们是变化的。将整个软件模块化，相互解耦，模块内部组件化，尽可能的减少依赖，面向接口编程。

## 优点
- 它使得软件实体具有灵活性，扩展性。模块/组件间相互解耦，后来者无需关心之前的模块怎么实现的，只需面向接口编程
- 测试简单，老的模块没有变化，只需要对新代码进行测试
- 为了实现开闭原则，不得不将模块间相互解耦并尽可能减小模块的粒度，同时也增强了模块的复用性


# 单一职责原则
**每个类，有且只有一个引起它变化的原因，否则它就应该被拆分**

当客户端需要某一个类的职责时，如果引入全部的职责会造成浪费，且一个职责的变化可能会影响其他职责，造成“莫名其妙”的错误

## 优点
- 单一职责的类你不会去复用整个对象处理其他职责，就减少了一个职责的改变影响到其他职责的问题
- 职责少了，代码肯定也简单了，易读性增强(包的组织和划分也变复杂了，小声逼逼...)
- 类粒度变小，复用性增强
