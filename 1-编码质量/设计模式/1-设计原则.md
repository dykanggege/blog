# 开闭原则

**软件应该对扩展开放，对修改关闭**：其含义是，当我们要对一个软件的功能做修改或扩展时，应该不修改之前的代码并扩展功能，以实现新的需求。其本质是**抽象约束，封装变化**

这就需要架构师具有前瞻性，提前分析出软件中哪些是可变的，哪些是不可变的，甚至对每一部分都不相信，假设他们是变化的。将整个软件模块化，相互解耦，模块内部组件化，尽可能的减少依赖，面向接口编程。

## 优点
- 它使得软件实体具有灵活性，扩展性。模块/组件间相互解耦，后来者无需关心之前的模块怎么实现的，只需面向接口编程
- 测试简单，老的模块没有变化，只需要对新代码进行测试
- 为了实现开闭原则，不得不将模块间相互解耦并尽可能减小模块的粒度，同时也增强了模块的复用性

# 里氏替换原则
**继承必须确保超类拥有的属性和功能在子类中仍然成立**，通俗的说，子类可以扩展父类的属性和功能，但不要覆盖和改变父类原有功能

里氏替换原则是对开闭原则的不同，它确保了动作的正确性，即类的扩展不会给系统引入错误，克服了重写父类带来的可用性变差的问题

# 依赖倒置原则
**高层模块不应该依赖于底层模块，他们都应该依赖于抽象，即抽象不依赖细节，细节依赖与抽象**，这是实现开闭原则的基本手段

每个类都尽可能的提供抽象接口，其他模块使用时应该使用抽象类或接口，类的继承应该遵循里氏替换原则

# 单一职责原则
**每个类，有且只有一个引起它变化的原因，否则它就应该被拆分**

当客户端需要某一个类的职责时，如果引入全部的职责会造成浪费，且一个职责的变化可能会影响其他职责，造成“莫名其妙”的错误

## 优点
- 单一职责的类你不会去复用整个对象处理其他职责，就减少了一个职责的改变影响到其他职责的问题
- 职责少了，代码肯定也简单了，易读性增强(包的组织和划分也变复杂了，小声逼逼...)
- 类粒度变小，复用性增强

# 接口隔离原则
**一个类对另一个类的依赖应该建立在最小接口上**，这是基本的封装原则，你应该暴露最高层的属性和方法，而不是什么都暴露出去，丧失了调用的可读性，调用者还容易瞎瘠薄调用

同时它的目的时尽可能减少类的职责，并降低类的颗粒度，增强可读性和复用性