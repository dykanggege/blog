# PATH
PATH是linux下的内置变量，像这样的内置全局变量还有很多，主要就是这个，PATH和windows下的环境变量含义相同

    echo $PATH //打印环境变量值

修改PATH

    export PATH=/new/path:$PATH

这种会在终端关闭后就失去效果了，如果想永久改变，必须要修改 /etc/profil文件

在profil文件下

    GOROOT=/usr/share/go
    export GOROOT
    export PATH=$PATH:GOROOT/bin

设置完成后要使用　source /etc/profile　重新调用该文件

# 全局变量
在linux中有一些全局变量我们可以直接获取值，path就是一个全局变量

    echo $PATH //要在前面加上$才能访问到，可能php就是受它影响了吧
    echo ${PATH} //这种方式也可以访问

使用 env 可以查看到所有的全局变量

我们可以直接设定一个全局变量

    echo ${myvar} //空值，没有这全局变量
    myvar = kanggegevar //设置了当前用户下的全局变量
    echo ${myvar} //kanggegevar
    //如果设定值有特殊字符，应该在外面使用 " " 或 \ 转义

我们在bash中调用的命令都是以bash为父进程，创建的子进程，子进程只能继承bash的系统全局变量，无法继承自己设置的全局变量

# 元字符

    *	代表『 0 个到无穷多个』任意字元
    ?	代表『一定有一个』任意字元
    [ ]	同样代表『一定有一个在括号内』的字元(非任意字元)。例如[abcd] 代表『一定有一个字元， 可能是a, b, c, d 这四个任何一个』
    [ - ]	若有减号在中括号内时，代表『在编码顺序内的所有字元』。例如[0-9] 代表 0 到9 之间的所有数字，因为数字的语系编码是连续的！
    [^ ]	若中括号内的第一个字元为指数符号(^) ，那表示『反向选择』，例如[^abc] 代表一定有一个字元，只要是非a, b, c 的其他字元就接受的意思。


    #	注解符号：这个最常被使用在script 当中，视为说明！在后的资料均不执行
    \	跳脱符号：将『特殊字元或万用字元』还原成一般字元
    |	管线(pipe)：分隔两个管线命令的界定(后两节介绍)；
    ;	连续指令下达分隔符号：连续性命令的界定(注意！与管线命令并不相同)
    ~	使用者的家目录
    $	取用变数前置字元：亦即是变数之前需要加的变数取代值
    &	工作控制(job control)：将指令变成背景下工作
    !	逻辑运算意义上的『非』 not 的意思！
    /	目录符号：路径分隔的符号
    >, >>	资料流重导向：输出导向，分别是『取代』与『累加』
    <, <<	资料流重导向：输入导向(这两个留待下节介绍)
    ' '	单引号，不具有变数置换的功能($ 变为纯文字)
    " "	具有变数置换的功能！($ 可保留相关功能)
    ` `	两个『 ` 』中间为可以先执行的指令，亦可使用$( )
    ( )	在中间为子shell 的起始与结束
    { }	在中间为命令区块的组合！

# 资料流重定向

    >  : 以覆盖的方法将命令打印的值输出到制定文档或装置上；
    >> : 累加
    1> ：以覆盖的方法将『正确的资料』输出到指定的档案或装置上；
    1>>：以累加的方法将『正确的资料』输出到指定的档案或装置上；
    2> ：以覆盖的方法将『错误的资料』输出到指定的档案或装置上；
    2>>：以累加的方法将『错误的资料』输出到指定的档案或装置上；
    <：由控制台输入变为文件输入

    eg:
        find /home -name .bashrc > list_right 2> list_error

## /dev/null 垃圾桶黑洞装置与特殊写法

想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？这个时候黑洞装置/dev/null 就很重要了！这个/dev/null 可以吃掉任何导向这个装置的资讯喔！将上述的范例修订一下：

    范例四：承范例三，将错误的资料丢弃，萤幕上显示正确的资料 
    [dmtsai@study ~]$ find /home -name .bashrc 2> /dev/null 
    /home/dmtsai/.bashrc   <==只有stdout会显示到萤幕上， stderr被丢弃了

再想像一下，如果我要将正确与错误资料通通写入同一个档案去呢？这个时候就得要使用特殊的写法了！我们同样用底下的案例来说明：


    范例五：将指令的资料全部写入名为list的档案中 
    [dmtsai@study ~]$ find /home -name .bashrc > list 2> list   <==错误 
    [dmtsai@study ~]$ find /home - name .bashrc > list 2>&1      <==正确 
    [dmtsai@study ~]$ find /home -name .bashrc &> list          <==正确

上述表格第一行错误的原因是，由于两股资料同时写入一个档案，又没有使用特殊的语法，此时两股资料可能会交叉写入该档案内，造成次序的错乱。所以虽然最终list档案还是会产生，但是里面的资料排列就会怪怪的，而不是原本萤幕上的输出排序。至于写入同一个档案的特殊语法如上表所示，你可以使用2>&1也可以使用&> ！一般来说，鸟哥比较习惯使用2>&1的语法啦！


# 指令
## ;
- cmd ; cmd (不考慮指令相關性的連續指令下達)

## $? (指令回传值) 与&& 或||
1. cmd1 && cmd2	
    1. 若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。
    2. 若cmd1执行完毕且为错误($?≠0)，则cmd2不执行。
2. cmd1 || cmd2	
    1.若cmd1执行完毕且正确执行($?=0)，则cmd2不执行。
    2.若cmd1执行完毕且为错误($?≠0)，则开始执行cmd2。

## 管线命令(pipe)
管线命令『 | 』仅能处理经由前面一个指令传来的正确资讯，也就是standard output的资讯，对于stdandard error并没有直接处理的能力

    管线命令仅会处理standard output，对于standard error output 会予以忽略
    管线命令必须要能够接受来自前一个指令的资料成为standard input 继续处理才行

## cut、grep
cut 是将一行讯息当中，取出某部分我们想要的，而grep 则是所有讯息， 若当中有我们所需要的资讯，就将该行拿出来～简单的语法是这样的：

    [dmtsai@study ~]$ grep [-acinv] [--color=auto] '搜寻字串' filename 
    选项与参数：
    -a ：将binary 档案以text 档案的方式搜寻资料
    -c ：计算找到'搜寻字串' 的次数
    -i ：忽略大小写的不同，所以大小写视为相同
    -n ：顺便输出行号
    -v ：反向选择，亦即显示出没有'搜寻字串' 内容的那一行！
    --color=auto ：可以将找到的关键字部分加上颜色的显示喔！

grep可以使用正则表达式查找 grep -n '^a' text

    [dmtsai@study ~]$ cut -d'分隔字元' -f fields  <==用于有特定分隔字元 
    [dmtsai@study ~]$ cut -c字元区间             <==用于排列整齐的讯息
    选项与参数：
    -d ：后面接分隔字元。与-f 一起使用；
    -f ：依据-d 的分隔字元将一段讯息分割成为数段，用-f 取出第几段的意思；
    -c ：以字元(characters) 的单位取出固定字元区间；

    echo ${PATH} //环境变量，是一行
    echo ${PATH} | cut -f':' -d 5 //以 : 分隔后第五个变量

## tee
使用 > 会将standout重定向到其他地方，这时打印台就没了，我们可以使用tee使得复制一份standout到其他地方，打印台还会有

    [dmtsai@study ~]$ tee [-a] file 
    选项与参数：
    -a ：以累加(append) 的方式，将资料加入file 当中！

    ls -al | tee ls.txt | grep filename
    //ls的输出被重定向到 tee 存储文件中，和 grep 筛选中