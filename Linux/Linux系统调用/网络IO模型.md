如果你要开一个餐厅，为了服务每个餐桌的客人，你有两种做法

第一，为每个餐桌都配置一个服务员，相当壕，一般只有有钱的大酒店才会这样做

第二，招一个服务员盯着所有桌，当某个餐桌上顾客有需求，就赶紧跑过去

我们把需要服务的餐桌看做Socket(IO流)，服务员看做Socket管理代码

第一种模型就是传统的多进程，每来一个socket请求，就会给他创建一个线程(招一个服务员？，太壕了)

第二种模型就是使用一个线程监听多个IO流的状态，即同时管理多个IO流。它的发明是尽可能提高服务器的吞吐力，如下图

![](img/1.jpg)

使用一个线程，就像接通电源一样，谁有数据就接通谁，然后调用对应的代码处理

select/poll/epoll都是IO多路复用的实现，但因为历史原因实现差异很大

# select
select是最早出现的

    int select(int maxfd, fd_set *readfds, fd_set *writefds, fe_set *exceptfds, const struct timeval *timeout);

- 调用时传入需要监控的socket文件数组，并且最多只能监控1024个链接，还特么不是线程安全的
- 如果某个socket出现了数据，他会修改数组里socket文件，然后返回，操蛋的是它不告诉你哪个socket文件有数据，你只能遍历数组查

那么他的缺点就很明显了，，，
1. 即使我们要添加一个socket进入，还是要把所有监控的socket传入，复制的开销太大
2. 每次select返回后，我们要自己遍历socket数组才能知道哪个有数据，浪费性能
3. 最大的缺陷就是1024

后来有人改了改，提供了poll，相对于select只是不再限制监控数量了，但是性能还不高

# epoll
- 线程安全
- 可以无限监控链接
- 每次加入值，无需全部拷贝
- 返回接收到数据的socket，不需要再去遍历了
















