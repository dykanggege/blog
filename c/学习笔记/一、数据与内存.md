# 编译器

1. GUN 是开源编译器组织
2. 不同平台的 c 编译器调用命令可能不同，但是默认都可以用 cc 调用
3. c99 和 c11 允许更长的标识符，但是编译器通常只识别前 63 个字符

# 数据类型

## 数值类型

- c 标准中并没有明确定义各种类型的大小，只是定义了 short < int <= long < long long，而不同系统上的编译器一般实现是 short(2) int(2/4) long(4) long long(8) float(4) double(8)
- 通过添加前缀 signed/unsigned 明确表示类型为有符号/无符号数
- 直接量通常是 int 类型，如果编译器发现 int 容量不够，进而使用 long，以此类推 long long，浮点数默认是 double 类型
- 在直接量后加 L 或 LL 或 F 甚至 uL 更改直接量类型为 long、long long、float、unsinged long
- 如果整形和浮点型同时出现在一个表达式中，整形默认会被转为浮点型，数值总是向上提升转换
- 在 limits.h 和 float.h 以常量的形式定义了整形和浮点型的最大/小值，和其他的数据

## 布尔类型

使用 _Bool 
除了 0 都是真。。。

## 字符与字符串

- char 表示单字节字符，'\0' 表示为 0 的字符，也就是 null 字符
- 字符串就是字符数组，char str[100]，字符数组中用 '\0' 字符表示字符串的结束，所以字符串数组的长度总应该比字符长度大 1

## 常量

- 转义字符常量
- /#define NAME "value"  全局宏定义常量，宏定义会在编译时全局替换，宏定义等于常量，不能再赋值
- const type variable = value; 声明常量字符串则要用 const char msg[10] = "kanggege"; 或 const char msg[] = "kanggege";
- 对数组而言，const 限定了数组的所有元素都不能被修改 const 

## 枚举
```
enum e {
    a = 1,
    b,
    c,
    d,
    e
};

enum e E;
E = e;
printf("%d",E); //5
//不使用命名空间，总觉得好丑
```

## 数组

- 声明 int arr[len]; int arr[8] = {1,2,3,4,5,6}
- c99 之后，数组声明时长度可以是变量
- 直接使用数组名不加下标，代表了数组的首地址

## 结构体


## 总结

1. 避免不同机器编译出问题，4 字节统一使用 long 类型
2. 声明常量字符串则要用 const char msg[10] = "kanggege"; 或 const char msg[] = "kanggege";
3. 对数组而言，const 限定了数组的所有元素都不能被修改
4. 地址和数组的关系，非常微妙，有很多黑魔法

# 作用域与存储期

全局作用域、函数作用域、块级作用域 你懂的

c 中定义的存储类别只有 auto(默认)、register、static、extern 他们并不是固定的，而是根据出现在不同的作用域有不同的功能

## static 存储期

static 静态，将变量硬编码在程序全局内存中

### 局部作用域下

一般的局部变量都是在栈空间（或者寄存器）中，声明局部变量后如果不赋值，它的值是随机的（只是分配了栈内存，并没有对原来栈内存的值进行重写）

加上 static 后，局部变量也会存储在全局内存空间中，但是访问权限限制在局部上下文中，并且一次声明后，下次再调用该局部上下文（函数之类），不会二次声明，总之，只会在运行程序时声明一次

例子：
```
#include<stdio.h>

void simple_var()
{
    int n = 10;
    printf("simple n %d\n",n);
    printf("simple n++ %d\n",++n);
}

void static_var()
{
    static int n = 10;
    printf("static n %d\n",n);
    printf("static n++ %d\n",++n);
}

int main(int argc, char const *argv[])
{
    simple_var();
    static_var();

    simple_var();
    static_var();

    getchar();
    return 0;
}

/*
simple n 10
simple n++ 11
static n 10
static n++ 11
simple n 10
simple n++ 11
static n 11
static n++ 12
*/

```

### 全局作用域
全局变量定义在函数体外部，在全局数据区分配存储空间，且编译器会自动对其初始化。

普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量）。

静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。

在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

### 函数

函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下：

- 静态函数只能在声明它的文件中可见，其他文件不能引用该函数
- 不同的文件可以使用相同名字的静态函数，互不影响

## extern

extern用在变量或函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用

## _Thread_local

创建调用一个线程时，它具有自己的变量，这些变量都是存在线程作用域中，线程创建时创建，线程结束时销毁

以关键字 _Thread_local 声明一个变量时，每个线程都会获得该变量的私有备份

## register

调用函数时，幸运的话参数和局部变量会被放在寄存器中，但是我们可以用 register 让他存在寄存器中，但我并不觉得有什么卵用，寄存器不多，并且能存放的数值类型也有限，多半是用不到的

# 内存分配

## malloc

我们现在已知的所有变量内存分配，都在程序编译后，已经指定了内存的位置（相对位置），即静态内存分配（局部变量在栈中动态分配）

我们也可以在程序运行过程中，动态分配全局内存，malloc() 函数会找到合适的空闲内存块，然后返回空闲内存的首地址，因此可以把它赋值给一个指针，使用指针访问这块内存，malloc也可能分配不到内存，则会返回一个 NULL

- malloc、free 等函数定义在 stdlib 中
- malloc 会返回一个通用内存指针 void \*，他可以接收任何类型的指针而不用强制类型转化
- 其实转换了，变为char \* 这样的一字节指针，但是我们无法直接使用它，所以无需用程序强制类型转换 
- 它可以通过强制类型转化变为任何其他的类型指针
- 需要注意的是，如果你对一个 void * 强转多个其他类型的指针，并同时使用，编译器不会拦你，你程序可能就完蛋了
- 如果内存不用了，就要即使 free(指向内存的指针) 否则就会内存泄漏，甚至有些系统在程序运行完成之后也不会回收这些内存
- calloc 和 malloc 同样分配内存，但 calloc 会在分配之后把内存块初始为 0

## restrict
它只能用于指针，表明改指针是访问数据对象的唯一且初始的方式

```
int * restrict restart = (int *) malloc(10 * sizeof(int))
```

用它之后，编译器会对该变量的操作进行整合，优化编译