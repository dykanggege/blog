net包下提供了 tcp/ip、udp、dns 的编程接口，以及Unix域的socket

虽然本包提供了对网络原语的访问，大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和类似的Dial和Listen函数。

# 简述

一个简单的demo来帮助入门net包编程

## tcp

server端

```
	//Listen不能监听udp，因为tcp会为每个请求建立连接，可以对每个连接处理，但是udp只能接受到一堆包，他应该有单独的处理方式
	//如果填写的IP地址为空，则会监听本机所有可用于单播和选播的IP地址，例 ":8080"
	//如果填写的端口为空，则会随机选择一个端口进行监听 例 "127.0.0.1"，或直接填写""
	listener, err := net.Listen("tcp", ":2000")
	fmt.Println("listen 2000...")
	if err != nil{
		panic(err)
	}
	for{
		conn, err := listener.Accept()
		if err != nil{
			log.Println(err)
			continue
		}

		go func(conn net.Conn) {
			reader := bufio.NewReader(conn)
			bytes, err := reader.ReadBytes('\r')
			if err != nil{
				log.Println(err)
				return
			}
			_, _ = conn.Write([]byte(bytes))
			_, _ = conn.Write([]byte("bye!\t"))
		}(conn)

	}

```

client端
```
	//ip地址和端口号都不能少
	conn, err := net.Dial("tcp", "127.0.0.1:2000")
	if err != nil{
		panic(err)
	}
	_, err = conn.Write([]byte("client:kanggege\n"))
	_, err = conn.Write([]byte(conn.LocalAddr().String()+"\n"))
	_, err = conn.Write([]byte("\r"))
	if err != nil {
		log.Println(err)
		return
	}

	reader := bufio.NewReader(conn)
	s, err := reader.ReadString('\t')
	if err != nil{
		log.Println(err)
		return
	}
	fmt.Println(s)

```

这个demo简单的实现了tcp编程（udp也是一样的）。有意思的一点是数据的流动，双方建立连接后，就可以接受或发送对方的数据了，直到双方任意一方结束连接前，数据都会被接受并缓存，有意思的就是对数据的处理

根据tcp协议，接收到的数据会被缓存，直到对方关闭连接才表示数据传输结束。如果要在一个tcp中实现多个应用层报文的传递，就要对缓存的信息提前做处理，而不是等到对方关闭连接后再处理，那么应用层报文之间应该有明显的开始或结束标志，便于我们识别分割点

在http协议中，以\r\n\r\n作为报文结束标识符，同时满足报文体长度=content-length，则代表一个完整报文。

我们从tcp中读取数据就是从缓存中读取，读取的长度和一次性读取的多少都是有意思的话题

## udp
```
	"net-work/socket/udp/config"
	const(
		SERVER_IP = "127.0.0.1"
		SERVER_PORT = 2000
		SERVER_REC_LEN = 30
	)

	//server
	//udp和tcp处理有明显的不同，tcp对对每一个连接单独处理，直到连接关闭为止，tcp是面向连接处理的
	//udp一次只处理一个报文，无论报文来源的IP和port，是面向报文处理的
	addr, err := net.ResolveUDPAddr("udp", config.SERVER_IP+":"+strconv.Itoa(config.SERVER_PORT))
	errPanic(err)
	conn, err := net.ListenUDP("udp", addr)
	errPanic(err)
	for{
		//如果读取缓存比报文段短，则只读取缓存长度，如果比报文段长，则读取报文段所有内容后剩下的是空的，不会阻塞
		//总之，它一次只处理一个报文
		data := make([]byte,config.SERVER_REC_LEN)
		_, addr, err := conn.ReadFromUDP(data)
		if err != nil{
			log.Println(err)
			continue
		}

		_, err = conn.WriteToUDP(bytes.ToUpper(data),addr)
		if err != nil{
			log.Println(err)
			continue
		}
	}

	//client
	for i := 0; i < 3; i++ {
		conn, err := net.Dial("udp", config.SERVER_IP+":"+strconv.Itoa(config.SERVER_PORT))
		if err != nil{
			log.Fatal(err)
		}
		_, err = conn.Write([]byte("我试试我能发多少信息"))
		if err != nil{
			log.Fatal(err)
		}

		data := make([]byte,30)
		_, err = conn.Read(data)
		if err != nil{
			log.Fatal(err)
		}
		fmt.Println(string(data))
		fmt.Println("发送完成")
	}

```