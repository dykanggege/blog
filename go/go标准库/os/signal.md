# 信号
操作系统信号是IPC中唯一一种异步的通信方法，他的本质是用软件来模拟硬件的中断。信号用来通知某个进程有某个事件发生了，在命令行按下某个键或者kill，都是发出信号给进程

使用 kill -l 查看所有的信号

linux下有62种信号，1-31属于标准信号，34-64属于实时信号

- 标准信号：又称为不可靠信号，对同一个进程来说，标准信号只会被记录和处理一次，如果发给某一进程的标准信号有多个，他们的处理顺序也完全不一定，所以是不可靠信号
- 实时信号：可靠信号，多个同一类的信号也会被记录，且他们可以按照信号发送的顺序被处理

简单来说，信号的来源有键盘输入、硬件故障、系统调用、非法运算。进程响应信号的方式有3中，捕捉、忽略、执行默认操作

对于绝大数标准信号来说，我们可以定义程序对他的响应方式。go通过os/signal一些API实现了对键盘信号的监听

```
	//接受信号的chan
	sigRecv := make(chan os.Signal, 1)
	//用哪个chan，选择处理哪些信号
	//syscall包下定义了各个系统支持的信号
	signal.Notify(sigRecv,syscall.SIGINT,syscall.SIGQUIT)
	for sig := range sigRecv{
		fmt.Println(sig)
		if sig != nil{
			//恢复系统默认的信号处理
			signal.Stop(sigRecv)
            close(sigRecv)
		}
	}
```

我们覆盖了对ctrl-c信号的处理，如果我们可以覆盖对任意信号的处理，那就太恐怖了，我们可以猥琐欲为了

在类unix平台下，SIGKILL、SIGSTOP信号是无法覆盖的，他保障了超级用户至高的权利
