其他语言在并发中大多使用的线程，go 中使用协程，他们之间存在着不小的差距
# goroutine 与线程
- os 中使用的线程都有一个固定的栈内存，通常大小为 2M，对于小的线程过于浪费，大的线程反而不够用，而每一个 goroutine 初始栈大小通常为 2k，而后可以增大或缩小，最大可到 1G 
- os 线程由 os 内核来调度，每隔几毫秒，一个硬件时针中断发送到 cpu，cpu 使用调度器暂停当前正在运行的线程，把它的寄存器信息保存到内存，查看线程表并决定接下来运行哪个线程，并从内存中恢复他们的注册表信息，线程间的上下文切换其实挺慢的。go 运行时包含一个自己的调度器，且不是用硬件时钟来触发的，而是通过特定的 go 语言结构触发，由于不需要切换到内核语境，所以调用一个 goroutine 比调度一个 os 线程成本低很多