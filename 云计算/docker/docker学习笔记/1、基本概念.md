# 镜像
对linux而言，内核启动后就会挂载root文件系统为其提供用户空间支持。docker的镜像也相当于root文件系统，为多个容器提供支持

## 分层存储
镜像只是一个虚拟的概念，并不是一个文件组成，而是由多层文件共同组成

镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变,后一层上的任何改变只发生在自己这一层。比如,删除前一层文件的操作,实际不是真的删除前一层的文件,而是仅在当前层标记为该文件已删除。在最终容器运行的时候,虽然不看到这个文件,但是实际上该文件会一直跟随镜像。因此,在构建镜像的时候,需要额外小心,每一层尽量只包含该层需要添加的东西,任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层,然后进一步添加新的层,以定制自己所需的内容,构建新的镜像。也可以有效减小镜像的体积（多个镜像公用层）

# 容器
镜像和容器的关系就像类和实例，容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程,但与直接在宿主执行的进程不同,容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间,甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里,使用起来,就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。

前面讲过镜像使用的是分层存储,容器也是如此。每一个容器运行时,是以镜像为基础层,在其上创建一个当前容器的存储层,我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。因此,任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求,容器不应该向其存储层内写入任何数据,容器存储层要保持无状态化。所有的文件写入操作,都应该使用 数据卷(Volume)、或者绑定宿主目录,在这些位置的读写会跳过容器存储层,直接对宿主(或网络存储)发生读写,其性能和稳定性更高。数据卷的生存周期独立于容器,容器消亡,数据卷不会消亡。因此,使用数据卷后,容器删除或者重新运行之后,数据却不会丢失。

# Docker Registry
docker镜像仓库类似于github，我们可以向上面拉取或推送镜像，一般在开发环境推送镜像，生产环境拉取镜像

可以使用阿里云的加速镜像

# 数据卷
将容器运行产生的数据或使用的文件和主机交互是很重要的，可以将容器的目录挂载在宿主机上，相当于Ｕ盘挂载一样
- docker run -it -v /myDataVolume:/dataVolumeContainer centos 将本地的一个文件夹像U盘一样挂载在容器中

## dockerfile VOLUME
镜像的描述文件，编写好 dockerfile　文件后，可以直接用命令生产　docker 镜像

- docker build -f dockerfile -t 新的镜像名 .(在当前目录下)
    - -f 指定要使用的 dockerfile 的路径
    - -t　镜像的名字和标签，通常指定 name:tag　如果不指定标签，则默认是最后版本


可以用　VＯLUME　指令给镜像添加一个或多个数据卷，如果只指定了镜像的数据卷，没有指定宿主机的挂载卷，则镜像自己会指定一个默认的挂载点

## --volumes-from 
docker run -it --name k1 kanggege/centos
docker run -it --name k2 --volumes-from k1 kanggege/centos  
将一个容器的数据卷挂载到另一个容器的挂载点上


# dockerfile

## 指令字
- FROM 基础镜像，类似与父类
- MAINTAINER 作者和作者的邮箱
- RUN 容器构建时需要执行的指令
- EXPOSE 当前容器对外暴露的端口
- WORKDIR 创建容器后，终端默认登录进来工作目录，落脚点
- ENV 在构建环境中设置的环境变量
- ADD 将宿主机目录下的文件拷贝进镜像且ＡＤＤ命令会自动处理ＵＲＬ和解压ｔａｒ压缩包
- COPY 类似于ADD，拷贝文件和目录到镜像中，只复制，不做特殊处理
- VOLUME　容器数据卷，持久化容器运行数据
- CMD 制定容器启动时要运行的命令，只有最后一条指令生效
- ENTRYPOINT 所有添加的指令都会生效
- ONBULID　当构建一个被继承的 dockerfile 时运行的命令，父镜像在被子镜像继承后父镜像的build 被触发

dockerfile 中每个指令都是一层，最好不要用太多指令（好像不能超过127层）
