# 镜像操作

## 获取镜像

    docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

- 地址的格式一般是 <域名/IP>\[:端口号\] 。默认地址是 Docker Hub。
- 如之前所说,这里的仓库名是两段式名称,即 <用户名>/<软件名> 。对于 Docker Hub,如果不给出用户名,则默认为 library ,也就是官方镜像。

## 查看镜像

    docker image ls [镜像名[:tag]]

为了加速镜像构建、重复利用资源,Docker 会利用 中间层镜像。所以在使用一段时间后,可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像,如果希望显示包括中间层镜像在内的所有镜像的话,需要加 -a 参数

    docker image ls -a

## 删除镜像

    docker image rm [选项] <镜像1> [<镜像2> ...]

其中, <镜像> 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要 

    docker image rm (docker image ls -q golang)

# 运行镜像


# 命令
- pull：拉取镜像 pull golang:tag 如果没指定版本号，则拉取最新版
- images:列出所有本地镜像
    - -a 列出本地所有镜像，含中间镜像
    - -q 只显示镜像的　id
    - --digests 显示镜像的摘要信息
    - --no-trunc 显示完整的镜像摘要信息
- search golang: 从dockerHub查找镜像
- rmi：删除镜像
    - -f 强制删除（即使正在运行）
- rm：删除容器
    - docker rm `docker ps -a -q`
- run hello-world：根据镜像启动容器，注意容器是和镜像不一样的概念，如果run实质是create container 并 start container，如果 run 后没有删除容器（ｒｍ），容器会一直存在，ps -a 可以查看所有的容器
    - -t 为容器重新分配一个伪终端，通常与　-i 一起使用
    - -i 以交互模式运行容器，通常和 -t 一起使用
    - -p 端口映射　docker run -it -p 8888:8080 tomcat 将　tomcat 的对外公开端口设置为 8888
    - -P 大Ｐ，随机分配映射端口
    - -d 后台访问，在后台运行
- ps：列出所有正在运行的容器
    - -a 列出当前正在运行的和历史上运行过的
    - -l 显示最近创建的容器
- kill id：杀死容器
- logs：日志
- attach centos：进入容器，使用 exit 会退出并杀死容器，ctrl+p+q 只是退出容器，这时候就可以用 docker attach centosID 重新进入容器
- exec：不进入容器直接执行命令（正在运行的容器），得到命令结想｀果
    - -t 分配一个伪终端，针对于长久运行的(centos)，如果只是一次运行(gcc)，则不需要该参数
- cp：拷贝容器内的数据到宿主机
- commit：提交新的容器镜像
- inspect imageID 查看运行容器的配置


# Dockerfile
Dockerfile 是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。

Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式,以及行首 # 进行注释的格式。良好的格式,比如换行、缩进、注释等,会让维护、排障更为容易,这是一个比较好的习惯

## FROM
docker的镜像是层层构建的，所以新的镜像可以依赖于已存在的镜像，FROM就是用来说明依赖的镜像

scratch 镜像是虚拟的概念,并不实际存在,它表示一个空白的镜像，没有依赖就可以用 FROM scratch

## RUN
RUN 指令是用来执行命令行命令的，其格式有两种
1. shell 格式: RUN <命令> ,就像直接在命令行中输入的命令一样。RUN echo '\<h1>Hello, Docker!\</h1>' > /usr/share/nginx/html/index.html
2. exec 格式: RUN \["可执行文件", "参数1", "参数2"\] ,这更像是函数调用中的格式。

每一个命令都会构建一层，太多的层毫无意义，所以尽可能的把所有的run命令写在一个命令中，RUN echo 1 && echo 2

## COPY
复制文件到镜像中

copy的源目录由构建时指定，目的根目录由WORKDIR指定

<源路径> 可以是多个,甚至可以是通配符,其通配符规则要满足 Go 的filepath.Match 规则,如:

    COPY hom* /mydir/
    COPY hom?.txt /mydir/

## CMD
容器启动的默认命令，和RUN类似，也有两种格式

在运行时可以指定新的命令来替代镜像设置中的这个默认命令,比如, ubuntu镜像默认的 CMD 是 /bin/bash ,如果我们直接 docker run -it ubuntu 的
话,会直接进入 bash 。我们也可以在运行时指定运行别的命令,如 docker run -it ubuntu cat /etc/os-release 。这就是用 cat/etc/os-release命令替换了默认的 /bin/bash 命令了,输出了系统版本信息。

在指令格式上,一般推荐使用 exec 格式,这类格式在解析时会被解析为 JSON数组,因此一定要使用双引号 " ,而不要使用单引号。

## 构建镜像
    
    docker build [选项] <上下文路径/URL/->
    -t 镜像名[：tag]
    -f 指定某个文件为 Dockerfile

上下文路径就是构建命令中的目录根路径，一般我们使用 . Dockerfile所在路径，如果有文件想被忽略，可以写一个 .dockerignore
