# 镜像操作
Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。

## 获取镜像

    docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]

- 地址的格式一般是 <域名/IP>\[:端口号\] 。默认地址是 Docker Hub。
- 如之前所说,这里的仓库名是两段式名称,即 <用户名>/<软件名> 。对于 Docker Hub,如果不给出用户名,则默认为 library ,也就是官方镜像，如果不加标签，则默认拉取最新版

    $ docker pull ubuntu:18.04
    18.04: Pulling from library/ubuntu

下载过程中可以明显看出分层，如果某一层已经存在则不用再下载了

## 查看镜像

    docker image ls [镜像名[:tag]]

为了加速镜像构建、重复利用资源,Docker 会利用 中间层镜像。所以在使用一段时间后,可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像,如果希望显示包括中间层镜像在内的所有镜像的话,需要加 -a 参数

    docker image ls -a

可以简便写法 images

- images:列出所有本地镜像
    - -a 列出本地所有镜像，含中间镜像
    - -q 只显示镜像的　id
    - --digests 显示镜像的摘要信息
    - --no-trunc 显示完整的镜像摘要信息

### 虚悬镜像

    <none>               <none>              00285df0df87        5 days ago          342 MB

这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：

    $ docker image ls -f dangling=true //查看虚悬镜像
    $ docker image prune //删除所有的虚悬镜像



## 运行镜像

    $ docker run -it --rm \
        ubuntu:18.04 \
        bash

运行镜像会产生一个容器，就像运行代码产生进程，我们还可以对容器进行管理，如果run后没有删除容器，容器会一直存在，ps -a 可以查看所有的容器，就像linux查看进程。

- it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。
- rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
- ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。
- bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。
- -p 端口映射　docker run -it -p 8888:8080 tomcat 将　tomcat 的对外公开端口设置为 8888
- -P 大Ｐ，随机分配映射端口
- -d 后台访问，在后台运行，并返回容器ID

## 删除镜像

    docker image rm [选项] <镜像1> [<镜像2> ...]

其中, <镜像> 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要 

    docker image rm (docker image ls -q golang)

## 定制镜像
定制镜像有两种方式 docker commit 或 Dockerfile，一般最好采用Dockerfile来完成，commit用于其他特殊场合


# Dockerfile
Dockerfile 是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。

Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式,以及行首 # 进行注释的格式。良好的格式,比如换行、缩进、注释等,会让维护、排障更为容易,这是一个比较好的习惯

## FROM
docker的镜像是层层构建的，所以新的镜像可以依赖于已存在的镜像，FROM就是用来说明依赖的镜像

scratch 镜像是虚拟的概念,并不实际存在,它表示一个空白的镜像，没有依赖就可以用 FROM scratch

## RUN
RUN 指令是用来执行命令行命令的，其格式有两种
1. shell 格式: RUN <命令> ,就像直接在命令行中输入的命令一样。RUN echo '\<h1>Hello, Docker!\</h1>' > /usr/share/nginx/html/index.html
2. exec 格式: RUN \["可执行文件", "参数1", "参数2"\] ,这更像是函数调用中的格式。

每一个命令都会构建一层，太多的层毫无意义，所以尽可能的把所有的run命令写在一个命令中，RUN echo 1 && echo 2

记得每一层构建的最后一定要清理掉无关文件

## COPY
复制文件到镜像中

copy的源目录由构建时指定，目的根目录由WORKDIR指定

<源路径> 可以是多个,甚至可以是通配符,其通配符规则要满足 Go 的filepath.Match 规则,如:

    COPY hom* /mydir/
    COPY hom?.txt /mydir/

## CMD
容器启动的默认命令，和RUN类似，也有两种格式

在运行时可以指定新的命令来替代镜像设置中的这个默认命令,比如, ubuntu镜像默认的 CMD 是 /bin/bash ,如果我们直接 docker run -it ubuntu 的
话,会直接进入 bash 。我们也可以在运行时指定运行别的命令,如 docker run -it ubuntu cat /etc/os-release 。这就是用 cat/etc/os-release命令替换了默认的 /bin/bash 命令了,输出了系统版本信息。

在指令格式上,一般推荐使用 exec 格式,这类格式在解析时会被解析为 JSON数组,因此一定要使用双引号 " ,而不要使用单引号。

## 构建镜像
    
    docker build [选项] <上下文路径/URL/->
    -t 镜像名[：tag]
    -f 指定某个文件为 Dockerfile

最后的上下文路径一般我们会用 . 即当前路径下，它代表的不是Dockerfile的存放路径，而是COPY、ADD等命令的根路径

在docker中分为client和server，我们使用client书写命令，调用server的远程API，在调用build命令时，其实是交给server来编译Dockerfile文件，所以client需要把上下文路径中所有文件打包给server，server才能找到编辑中命令需要的文件。所以我们应该把所需文件复制到Dockerfile所在文件夹中，否则可能会打包很多无用的资源，如果用 / 作为上下文编译，那还需要打包整个硬盘文件！同时也在说明：**copy中无法使用 .. 路径**

如果没有用 -f 指定文件名，默认使用当前文件夹下的 dockerfile/Dockerfile 文件

如果有文件想被忽略，可以写一个 .dockerignore

也可以使用远程文件直接构建

    docker build https://github.com/twang2218/gitlab-ce-zh.git#:11.1



# 数据卷
将容器运行产生的数据或使用的文件和主机交互是很重要的，可以将容器的目录挂载在宿主机上，相当于Ｕ盘挂载一样
- docker run -it -v /myDataVolume:/dataVolumeContainer centos 将本地的一个文件夹像U盘一样挂载在容器中

## dockerfile VOLUME
镜像的描述文件，编写好 dockerfile　文件后，可以直接用命令生产　docker 镜像

- docker build -f dockerfile -t 新的镜像名 .(在当前目录下)
    - -f 指定要使用的 dockerfile 的路径
    - -t　镜像的名字和标签，通常指定 name:tag　如果不指定标签，则默认是最后版本


可以用　VＯLUME　指令给镜像添加一个或多个数据卷，如果只指定了镜像的数据卷，没有指定宿主机的挂载卷，则镜像自己会指定一个默认的挂载点

## --volumes-from 
docker run -it --name k1 kanggege/centos
docker run -it --name k2 --volumes-from k1 kanggege/centos  
将一个容器的数据卷挂载到另一个容器的挂载点上


# dockerfile

## 指令字
- FROM 基础镜像，类似与父类
- MAINTAINER 作者和作者的邮箱
- RUN 容器构建时需要执行的指令
- EXPOSE 当前容器对外暴露的端口
- WORKDIR 创建容器后，终端默认登录进来工作目录，落脚点
- ENV 在构建环境中设置的环境变量
- ADD 将宿主机目录下的文件拷贝进镜像且ＡＤＤ命令会自动处理ＵＲＬ和解压ｔａｒ压缩包
- COPY 类似于ADD，拷贝文件和目录到镜像中，只复制，不做特殊处理
- VOLUME　容器数据卷，持久化容器运行数据
- CMD 制定容器启动时要运行的命令，只有最后一条指令生效
- ENTRYPOINT 所有添加的指令都会生效
- ONBULID　当构建一个被继承的 dockerfile 时运行的命令，父镜像在被子镜像继承后父镜像的build 被触发

dockerfile 中每个指令都是一层，最好不要用太多指令（好像不能超过127层）


# 命令
- pull：拉取镜像 pull golang:tag 如果没指定版本号，则拉取最新版
- images:列出所有本地镜像
    - -a 列出本地所有镜像，含中间镜像
    - -q 只显示镜像的　id
    - --digests 显示镜像的摘要信息
    - --no-trunc 显示完整的镜像摘要信息
- search golang: 从dockerHub查找镜像
- rmi：删除镜像
    - -f 强制删除（即使正在运行）
- rm：删除容器
    - docker rm `docker ps -a -q`
- ps：列出所有正在运行的容器
    - -a 列出当前正在运行的和历史上运行过的
    - -l 显示最近创建的容器
- kill id：杀死容器
- logs：日志
- attach centos：进入容器，使用 exit 会退出并杀死容器，ctrl+p+q 只是退出容器，这时候就可以用 docker attach centosID 重新进入容器
- exec：不进入容器直接执行命令（正在运行的容器），得到命令结想｀果
    - -t 分配一个伪终端，针对于长久运行的(centos)，如果只是一次运行(gcc)，则不需要该参数
- cp：拷贝容器内的数据到宿主机
- commit：提交新的容器镜像
- inspect imageID 查看运行容器的配置