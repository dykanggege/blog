# 冒泡排序
```
//冒泡排序
//稳定排序，O(n^2)
func BubbleSort(arr []int)  {
	l := len(arr)
	if l < 2 {return}
	for i := 0; i < l-1; i++ {
		for j := 0; j < l-i-1; j++ {
			if arr[j] > arr[j+1]{
				arr[j],arr[j+1] = arr[j+1],arr[j]
			}
		}
	}
}
```

# 插入排序
```
//插入排序
//不稳定排序，最坏情况和冒泡一样，O(n^2)，最好情况O(n-1)，即已经排序好的
func InsertSort(arr []int)  {
	l := len(arr)
	if l < 2 {return}
	for i := 1; i < l; i++ {
		for j := i; j > 0; j-- {
			if arr[j] < arr[j-1]{
				arr[j],arr[j-1] = arr[j-1],arr[j]
			}else{
				break
			}
		}
	}
}

```

# 归并排序
```
//归并排序
//稳定排序，性能为为O(nlogn)，但是额外占用O(n)的内存，性能是略好于快排的，但是内存用的太多了
func MergeSort(arr []int)  {
	l := len(arr)
	if l < 2 {return}
	temp := make([]int,l)
	mergeSort(arr,temp,0,l-1)
}

func mergeSort(arr,temp []int,left,right int)  {
	if left < right{
		center := (left+right)/2
		mergeSort(arr,temp,left,center)
		mergeSort(arr,temp,center+1,right)
		merge(arr,temp,left,center,right)
	}
}

func merge(arr,temp []int,left,center,right int)  {
	l,r,i := left,center+1,0
	for l <= center && r <= right{
		if arr[l] < arr[r]{
			temp[i] = arr[l]
			l++
		}else{
			temp[i] = arr[r]
			r++
		}
		i++
	}
	for ;l <= center; l++ {
		temp[i] = arr[l]
		i++
	}
	for ;r <= right; r++{
		temp[i] = arr[r]
		i++
	}
	for j := 0; j < i; j++ {
		arr[left+j] = temp[j]
	}
}
```

# 计数排序
```
//计数排序
//不基于比较，复杂度为O(n)，但是只能用于整数，且要提前知道最大小值，如果差距过大，占据的空间太浪费了
func NumSort(arr []int,min,max int)  {
	l := max-min+1
	temp := make([]int,l)
	for _,v := range arr{
		if v < min || v > max{
			panic("index out of range")
		}
		temp[v]++
	}

	index := 0
	for i,v := range temp{
		for v > 0 {
			arr[index] = i+min
			v--;index++;
		}
	}
}

```

# 快速排序
快速排序和归并排序的都是nlogn，总结他们的做法就发现，想要实现logn就必须要分治，分治的越平均越接近logn
```
func QuickSort(arr []int)  {
	base := media(arr)
	l := len(arr)
	if l < 4{
		return
	}
	left,right := 1,l-2

	for {
		for arr[left] < base && left < right{ left++ }
		for arr[right] > base && left < right { right-- }
		if left < right{
			arr[left],arr[right] = arr[right],arr[left]
		}else{
			break
		}
	}
	
	if arr[left] < base { left++ }

	QuickSort(arr[0:left])
	QuickSort(arr[left:l])
}

func media(arr []int) int {
	l := len(arr)
	if l < 2{
		return 0
	}
	l--
	m := l/2
	if arr[0] > arr[m] {
		arr[0],arr[m] = arr[m],arr[0]
	}
	if arr[m] > arr[l] {
		arr[m],arr[l] = arr[l],arr[m]
	}
	if arr[0] > arr[m] {
		arr[0],arr[m] = arr[m],arr[0]
	}
	if l < 4{
		return 0
	}
	arr[m],arr[l-1] = arr[l-1],arr[m]
	return arr[l-1]
}
```
## TopN
利用快排的思想可以很好的解决TopN问题

我们可以维持一个大小为N+1的堆，遍历数据将他维护在堆中，就得到了TopN，复杂度为(logN)n，因为N是一个常量，所以O(n)复杂度，随着N增大，复杂度也会上次

或者使用快排的分解，选择base点，小的放左边大的放右边，最后最左边的几个就是最小的几个，复杂度一般不到2n，N越大，复杂度越小

## 优化排序
如果想优化快排，最明显的就是从分界点和递归入手

如果本来就是从小到大的数组，而我们每次选择的分界点都是最左边，快排就会退化成O(n^2)，可以使用随机选择，或则三位取中，最好用三位取中，还可以增加哨兵

当要排序的数据量较小时，可以直接用归并排序，大数据在用快排，但是大数据在快排递归时很容易爆栈，可以用堆模拟栈优化递归，且在数量比较小时改用其他排序算法
