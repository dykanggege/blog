链表：
- 插入、删除高效，查找只能靠遍历
- 本质：内存非连续，遍历比数组慢

数组：
- 查找高效，中间插入和删除低效
- 本质：连续分配的内存

# 双指针
链表中的双指针能解决很多经典问题，应该多考虑使用双指针甚至多指针解决链表问题

# 环型链表
一个快跑和慢跑的人，在一个直线上，可能不会相遇，如果在操场上环行跑，则快的一定会追上慢的，这就是用快慢指针判断是否是环形链表的思路

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    //注意考虑边界值情况
    if head == nil || head.Next == nil{
        return false
    }
    fast,slow := head,head
    for fast.Next != nil && fast.Next.Next != nil{
        slow = slow.Next
        fast = fast.Next.Next
        if fast == slow{return true}
    }
    return false
}
```

# 相交链表

如果A、B相交，那么A+B == B+A，用双指针遍历A+B和B+A，一定会在相交的地方相遇

```
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil{
        return nil
    }
    if headA == headB{
        return headA
    }
    
    p1,p2 := headA,headB
    flag1,flag2 := false,false
    for p1 != p2 {
        p1 = p1.Next
        p2 = p2.Next
        if p1 == nil{
            if flag1 {
                return nil
            }
            flag1 = true
            p1 = headB
        }
        if p2 == nil{
            if flag2 {
                return nil
            }
            flag2 = true
            p2 = headA
        }
    }
    return p1
}
```

## 删除倒数第n个节点

很好的一个考虑边界情况的示例

```
    /**
    * Definition for singly-linked list.
    * type ListNode struct {
    *     Val int
    *     Next *ListNode
    * }
    */
    //n是负数、n越界、n是0或最大值
    func removeNthFromEnd(head *ListNode, n int) *ListNode {
        if head == nil{
            return head
        }
        
        count,end,endPrev := 1,head,head
        for end.Next != nil{
            endPrev = end
            end = end.Next
            count++
        }
        
        //n可能是负数
        if n < 0 && -n <= count{
            n = -n
        }else if n > 0 && n <= count{
            n = count - n + 1       
        }else{
            return head
        }
        
        if n == 1{
            n := head.Next
            head.Next = nil
            return n
        }
        if n == count{
            endPrev.Next = nil
            return head
        }
        
        node := head
        for i := 1; i < n-1; i++{
            node = node.Next
        }
        del := node.Next
        node.Next = node.Next.Next
        del.Next = nil
        return head
    }

```