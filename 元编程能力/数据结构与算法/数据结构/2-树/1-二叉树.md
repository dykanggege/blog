二叉树是搜索树的一种搜索树，本质是用链表，左小右大，将不同节点关联起来，最好的情况查找和插入一个节点就是 logn 

但是也可能会出现一边倒的情况，造成查找最差情况为 n

通常我们所说的搜索树一般是 2-搜索树，当然也有3-、4-视情况选择不同的搜索树


```
    package main

    import (
        "container/list"
        "fmt"
    )

    type TreeKey interface {
        Equal(key interface{}) int
    }

    type Node struct {
        Key TreeKey
        Val interface{}
        Left *Node
        Right *Node
    }

    type Tree struct {
        root *Node
    }

    func NewTree(key TreeKey,val interface{}) *Tree {
        n := &Node{Key:key,Val:val}
        return &Tree{root:n}
    }

    func (t *Tree) Get(k TreeKey) interface{} {
        return search(t.root,k).Val
    }

    func (t *Tree) Add(k TreeKey,v interface{})  {
        n := &Node{Key:k,Val:v}
        add(t.root,n)
    }

    func (t *Tree)Remove(key TreeKey) (val interface{}) {
        return remove(t.root,key)
    }

    func remove(node *Node,key TreeKey) (val interface{}) {
        switch node.Key.Equal(key) {
        case 1:
            return remove(node.Left,key)
        case -1:
            return remove(node.Right,key)
        case 0:
            if node != nil {
                val = node.Val
                if node.Left == nil && node.Right == nil{
                    //左右子树是空的
                    node = nil
                }else if node.Left == nil && node.Right != nil{
                    //左空
                    node = node.Right
                    node.Right = nil
                }else if node.Left != nil && node.Right == nil{
                    //右空
                    node = node.Left
                    node.Left = nil
                }else{
                    //左右都非空
                    node = node.Left
                    remove(node.Left,key)
                }
                return
            }
        }
        return nil
    }

    func (t *Tree) LeftPrint()  {
        leftPrint(t.root)
    }

    func (t *Tree) LeftPrintIter()  {
        l := list.New()
        node := t.root

        for node != nil || l.Len() != 0{
            for node != nil{
                fmt.Println(node.Val)
                l.PushBack(node)
                node = node.Left
            }
            if l.Len() != 0{
                node = l.Remove(l.Back()).(*Node).Right
            }
        }
    }


    func search(node *Node,k TreeKey) *Node {
        if node == nil{
            return nil
        }
        switch node.Key.Equal(k) {
        case 0:
            return node
        case 1:
            return search(node.Left,k)
        case -1:
            return search(node.Right,k)
        }
        return nil
    }

    func add(node,nnode *Node)  {
        switch node.Key.Equal(nnode.Key){
        case 0:
            node.Val = nnode.Val
        case 1:
            if node.Left == nil{
                node.Left = nnode
            }else{
                add(node.Left,nnode)
            }
        case -1:
            if node.Right == nil{
                node.Right = nnode
            }else{
                add(node.Right,nnode)
            }
        }
    }

    type key int
    func (k key) Equal(kk interface{}) int {
        v := kk.(key)
        if int(k) > int(v){
            return 1
        }
        if int(k) < int(v){
            return -1
        }
        return 0
    }


    func leftPrint(node *Node)  {
        if node == nil{
            return
        }
        fmt.Println(node.Val)
        leftPrint(node.Left)
        leftPrint(node.Right)
    }

    func main() {
        //tree := NewTree(key(5),"666")
        //for i:=0; i<20; i++{
        //	tree.Add(key(i),strconv.Itoa(i))
        //}
        ////tree.LeftPrint()
        //tree.LeftPrintIter()
    }
```