# 变量

## 声明
- 变量声明不可变，但可覆盖
```
const MAX_VAL :i32 = 100; //常量总是不可变，明确类型，且不可覆盖，常量是硬编码

fn main() {
    let _var = 1;
    let _var = 2; //可覆盖，本质是创建了新的变量，复用了_var名字
    _var = 3; //错误，let默认声明不可变量

    let mut _a = 'a'; //let mut声明变量可变
    _a = 'b'; 
}
```

## 类型
- 编译器会尽可能推导变量类型，若有多种可能，无法推导，需 :i32 明确类型

- 数值：i8、u8、i16、u16、i32、u32、i64、u64、isize、usize、f32、f64、bool
- 字符：char 代表一个unicode字符

- 元组：可用于函数多返回值
```
    let tup = (1, 1.1, '♂');
    let (x, y, z) = tup;

    println!("{}", tup.2)
```

- 数组：丑爆了
```
let arr: [i32; 5] = [];
arr[6]; //rust提供运行时检查，如果超过数组范围会panic
```

- 函数：丑到无敌

```
fn nb(a: i32, b: i32, c: char) -> i32 {
    let x = 1;
    x+1 //没有分号的表达式就是返回值
}
```

# 控制流
```
if true {} //只接受布尔类型，nice

let condition = true;
let number = if condition { //算是小小的语法糖吧，也不是很有必要
    5
} else {
    6
};

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;
    }
};


let a = [10, 20, 30, 40, 50];
let mut index = 0;

while index < 5 {
    println!("the value is: {}", a[index]);

    index = index + 1;
}

for element in a.iter() {
    println!("the value is: {}", element);
}

for number in (1..4).rev() {
    println!("{}!", number);
}
```

