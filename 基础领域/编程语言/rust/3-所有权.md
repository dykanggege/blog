# 变量所有权
现在主流的编程语言通过两种方式管理内存 GC、手动 两种各有自己的优缺点，rust采用所有权改进了手动的缺点，让这些缺点提前暴露在编译中...

如果变量分配在栈上，函数调用结束回退栈会自动回收，如果分配在内存上需要GC或者手动回收

编程语言一定会有作用域范围的概念，如果在离开作用域时自动回收该作用域变量分配的空间，那么就不需要GC且不需要手动了，当然这是理想的情况，要满足这个理想情况必须满足所有权

- rust中每个内存值有且只有一个变量对应，即他的所有者
- 当所有者离开作用域，值会被回收

```
fn main() {
    let x = 5;
    let y = x; //基本类型可以在栈上分配，无需遵守所有权规则，而且赋值的本质是copy

    let s1 = String::from("hello"); //会被分配到堆中，只有一个所有者
    let s2 = s1; //浅拷贝，所有权被转交给s2了
    println!("{}",s1); //s1不能再被使用，他不是字符串值的所有者了
    
    let s3 = s2.clone(); //深拷贝，重新创建值并将所有权交给s3
    println!("{}",s2); //s2具有原值所有权，正常使用
    println!("{}",s3);
}
```

栈上分配内存或深copy类型，基本类型

- 所有整数类型，比如 u32。
- 布尔类型，bool，它的值是 true 和 false。
- 所有浮点数类型，比如 f64。
- 字符类型，char。
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。

向函数传递引用类型或返回值都是传递所有权，浅拷贝都是传递所有权

## 引用
```
//由于传参被剥夺所有权，你不得不再返回一个所有权
fn tt(str :string) -> (string,usize) {
    (str,String::len(str))
}
```

为了解决这种脱裤子放屁的行为，提供了引用&，引用允许使用值但不获取所有权

![](img/1.svg)

```
fn tt(str :&string) -> usize {
    String::len(str)
} //在函数生命周期结束后归还变量
```

正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。

### 可变借用

加上mut变得可变

```
fn main() {
    let mut s = String::from("hello");
}
fn change(str: &mut String) {
    str.push_str(",world");
}
```

但借用也有限制，在特定区域下特定数据有且只有一个可变引用

```
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}{}",r1,r2); //会报错
}
```

禁止对同一数据同一区域多个可变引用可以避免数据竞争

```
let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &mut s;
```

只要不在同一个区域下数据竞争，就可以允许，一定要记住编译器是为了帮你避开以后的一些坑，你要明白哪些是坑就知道该怎么写了

```
    let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;

    println!("{}{}",r1,r2); //在此之后s1、s2生命结束了
    println!("{}",&mut s); //编译器明白没有数据竞态了，允许你操作了
```

### 空引用
```
fn danger() -> &String {
    let s = String::from("hello");
    &s 
}//s到这里生命周期就结束了，返回的引用将是空的，所以报错
```

## 规则
总结上面可以发现规律：
 
- 为了有效追踪引用变量的生命周期，所以提出了所有权的转移
- 为了避免数据竞争，所以默认数据不可变，并提出了mut，在并行编程下有很大意义

# slice
    
    let hello = &s[0..5]; //获取0~4字符串

- [0..=5] 获取0~5
- [..]
- 字符串的切片叫做&str