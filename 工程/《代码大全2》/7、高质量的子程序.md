创建子程序的正当理由
- 降低复杂度，在主程序中只留下整体处理逻辑，隐藏处理细节
- 抽象代码，如果多处用到相同的程序，就应该考虑抽象出来单独维护，避免多处维护
- 提高可重用性，这个子程序的功能能否用到其他项目中呢
- 简化复杂的布尔判断，很多代码中在做布尔判断时，用了一大坨代码，其实我只关心判断的目的和成功与否，不关心代码逻辑
- 改善性能，当性能出现问题时，更容易精准的锁定出现问题的地方

# 内聚性与耦合度
- 功能的内聚性：一个子程序仅执行一个操作
- 顺序的内聚性：假如一个子程序根据给定的出生年月计算年龄和退休日期，如果用出生年月计算了年龄，再用年龄计算退休日期，则子程序具有顺序内聚性，如果用出生年月计算年龄，再用出生年月计算退休日期，则是通信的内聚性，这样这个子程序可以分解为两个子程序，其他子程序可以调用两者或者二者分之一
- 通信上的内聚性：一个子程序的不同操作使用了相同的数据，但不存在其他的关联关系，这种子程序要视情况继续拆分
- 临时的内聚性：用来组织一个或多个子程序，实现一种操作，注意功能要单一
- 做的越多，越容易出错

除了这些外，其他的内聚都是不可取的

# 子程序的命名
应当清晰的描述子程序功能及其副作用，例如：计算报表的总额并打开一个文件输出，ComplateReportTotals() 就不算完整，应该带上它的副作用 ComplateReportTotalsAndOutputFile()，但是这样又会让名字过长，另一种编程方式就是直接了当解决问题，不让子程序产生副作用

子程序的命名应当是准确的，不应该使用 handlexxx、formatxxx 之类模糊不清的名，如果一个子程序的功能就是模糊不清的，那么它应该被重新组织