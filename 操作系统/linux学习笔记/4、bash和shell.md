# 元字符

    *	代表『 0 个到无穷多个』任意字元
    ?	代表『一定有一个』任意字元
    [ ]	同样代表『一定有一个在括号内』的字元(非任意字元)。例如[abcd] 代表『一定有一个字元， 可能是a, b, c, d 这四个任何一个』
    [ - ]	若有减号在中括号内时，代表『在编码顺序内的所有字元』。例如[0-9] 代表 0 到9 之间的所有数字，因为数字的语系编码是连续的！
    [^ ]	若中括号内的第一个字元为指数符号(^) ，那表示『反向选择』，例如[^abc] 代表一定有一个字元，只要是非a, b, c 的其他字元就接受的意思。


    #	注解符号：这个最常被使用在script 当中，视为说明！在后的资料均不执行
    \	跳脱符号：将『特殊字元或万用字元』还原成一般字元
    |	管线(pipe)：分隔两个管线命令的界定(后两节介绍)；
    ;	连续指令下达分隔符号：连续性命令的界定(注意！与管线命令并不相同)
    ~	使用者的家目录
    $	取用变数前置字元：亦即是变数之前需要加的变数取代值
    &	工作控制(job control)：将指令变成背景下工作
    !	逻辑运算意义上的『非』 not 的意思！
    /	目录符号：路径分隔的符号
    >, >>	资料流重导向：输出导向，分别是『取代』与『累加』
    <, <<	资料流重导向：输入导向(这两个留待下节介绍)
    ' '	单引号，不具有变数置换的功能($ 变为纯文字)
    " "	具有变数置换的功能！($ 可保留相关功能)
    ` `	两个『 ` 』中间为可以先执行的指令，亦可使用$( )
    ( )	在中间为子shell 的起始与结束
    { }	在中间为命令区块的组合！

# 资料流重定向

    1> ：以覆盖的方法将『正确的资料』输出到指定的档案或装置上；
    1>>：以累加的方法将『正确的资料』输出到指定的档案或装置上；
    2> ：以覆盖的方法将『错误的资料』输出到指定的档案或装置上；
    2>>：以累加的方法将『错误的资料』输出到指定的档案或装置上；
    <：由控制台输入变为文件输入

    eg:
        find /home -name .bashrc > list_right 2> list_error

## /dev/null 垃圾桶黑洞装置与特殊写法

想像一下，如果我知道错误讯息会发生，所以要将错误讯息忽略掉而不显示或储存呢？这个时候黑洞装置/dev/null 就很重要了！这个/dev/null 可以吃掉任何导向这个装置的资讯喔！将上述的范例修订一下：

    范例四：承范例三，将错误的资料丢弃，萤幕上显示正确的资料 
    [dmtsai@study ~]$ find /home -name .bashrc 2> /dev/null 
    /home/dmtsai/.bashrc   <==只有stdout会显示到萤幕上， stderr被丢弃了

再想像一下，如果我要将正确与错误资料通通写入同一个档案去呢？这个时候就得要使用特殊的写法了！我们同样用底下的案例来说明：


    范例五：将指令的资料全部写入名为list的档案中 
    [dmtsai@study ~]$ find /home -name .bashrc > list 2> list   <==错误 
    [dmtsai@study ~]$ find /home - name .bashrc > list 2>&1      <==正确 
    [dmtsai@study ~]$ find /home -name .bashrc &> list          <==正确

上述表格第一行错误的原因是，由于两股资料同时写入一个档案，又没有使用特殊的语法，此时两股资料可能会交叉写入该档案内，造成次序的错乱。所以虽然最终list档案还是会产生，但是里面的资料排列就会怪怪的，而不是原本萤幕上的输出排序。至于写入同一个档案的特殊语法如上表所示，你可以使用2>&1也可以使用&> ！一般来说，鸟哥比较习惯使用2>&1的语法啦！
# 指令
## ;
- cmd ; cmd (不考慮指令相關性的連續指令下達)

## $? (指令回传值) 与&& 或||
1. cmd1 && cmd2	
    1. 若cmd1执行完毕且正确执行($?=0)，则开始执行cmd2。
    2. 若cmd1执行完毕且为错误($?≠0)，则cmd2不执行。
2. cmd1 || cmd2	
    1.若cmd1执行完毕且正确执行($?=0)，则cmd2不执行。
    2.若cmd1执行完毕且为错误($?≠0)，则开始执行cmd2。

## 管线命令(pipe)
管线命令『 | 』仅能处理经由前面一个指令传来的正确资讯，也就是standard output的资讯，对于stdandard error并没有直接处理的能力

    管线命令仅会处理standard output，对于standard error output 会予以忽略
    管线命令必须要能够接受来自前一个指令的资料成为standard input 继续处理才行

