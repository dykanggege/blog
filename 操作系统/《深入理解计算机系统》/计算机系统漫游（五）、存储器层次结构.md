寄存器 > 高速缓存 > 主存 > 磁盘，计算机内部有着井然有序的存储层次，越靠近 cpu 的存储结构速度越快，访问寄存器甚至是0个周期，而访问主存要上百个周期，磁盘甚至达到了千万个周期。

# 控制器
主存中的存储被分为多个模块，每个模块中是一个个的小单元，通过控制器按坐标访问不同模块，就能得到对应的字节。

总之，总线访问主存，读或写入数据，如果读写磁盘的数据，则仍要通过主存间接访问（磁盘数据先被放到主存种，然后cpu访问主存）

cpu访问磁盘或其他数据，先向这些IO设备的控制器发出信号，并在内存种分配空间，IO设备将数据放在内存空间后，cpu再去使用这些数据。根据这些原理，衍生了IO的缓冲，异步，非阻塞等等理论

# 总线
cpu 通过总线访问主存，每次cpu和主存的数据传送都是通过一系列步骤来完成的，这些步骤称为**总线事务**。

读事务从主存传输数据到cpu，写事务从cpu传入数据到主存

总线是一组并行的导线，能携带地址、数据和控制信号

# 局部性
存储层次的特点也决定了将不同数据放在不同的层次结构中，这个思想围绕着计算机一个叫局部性的属性。

良好的局部性程序应该访问最近的存储结构（缓存原理）

## 空间局部性
空间局部性是指，尽可能小步的（两个地址之间的距离）访问内存，大步的在内存中跳跃很浪费性能，如下
```
// 不好的空间局部性
int arr[10][10];
int sum = 0;

for(int i = 0; i < 10; i++)
{
    for(int j = 0; j < 10; j++)
    {
        sum += arr[j][i];
    }
}
// 好的空间局部性，将上面数组访问的顺序改为 arr[i][j]，减小了内存跳跃跨度
```
## 时间局部性
时间局部性是指，尽可能访问最近时间内（逻辑上）最近的遍历

# 存储器层次结构

## 缓存读
存储器层次结构的中心思想是：对于每个K，位于 k 层的更快更小的存储器作为 k+1 层设备的缓冲

k+1层的存储器都被划分为连续的数据对象组块，每个块都有自己唯一的名字（地址），硬件的块一般是固定的，而像网络上请求的文件大小则是变化的

数据总是以块为传送单元在 k 和 k+1 层传递。如：L1 L0 之间传输使用 1 个字大小的块，L3 和 L2 之间用几十字节的块，L5 和 L4 传输几百字节的块。层次结构越低的存储器访问时间越长，尽可能的减少这么长的访问时间，越是远，越倾向于使用大的块（以我们写的程序要有良好的空间局部性为前提）

1. 缓存命中：当程序需要在K+1层读取一个数据d，首先会在K层查找，如果找到了数据d，则我们称为缓存命中。
2. 缓存不命中：如果没有在k层找到数据d，则缓存不命中，会把d读取到k，如果k已经满了，则覆盖一个现存的块。这个过程称为替换（驱逐），被替换的块被称为牺牲块，决定替换哪个块是由缓存的替换策略决定的

时间局部性使得最近访问的数据总是在缓存中，因为每次缓存的是一段数据，使得空间局部性也可以很好的利用缓存

## 缓存写
如果我们要写入一个高速缓存中的字，写命中后有两种策略

1. 直写：在高速缓存中更改d的副本后，接着修改下一级缓存的d，把所有的d都需改一次，这样很浪费总线
2. 写回：先修改最近的d缓存副本，等到d要被替换时再去写入到低级一层中

