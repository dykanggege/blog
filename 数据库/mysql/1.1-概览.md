![](imgs/1.png)

总的来说mysql可以分为 server 层和存储层

# server

所有跨存储引擎的功能都在server层实现，例如存储过程、触发器、试图等

## 连接器
用于管理连接，权限验证

    mysql -h$ip -P$port -u$user -p

用户名密码通过后会查你的权限，而后你的所有执行都依赖于查到的权限，这意味这你连接后再改你的权限并不能在当前连接中生效

连接后如果没有动作就是空闲连接，默认8小时没有动作自动断开，由 wait_timeout 参数控制

长连接多次查询使用一个连接，短连接每次查询都新建连接

如果全部使用长连接，可能会发现Mysql占用内存增长特别快，因为mysql在执行过程中临时使用的内存是管理在连接对象中的，连接断开后才会释放

可以每过一段时间断开一次长连接，或5.7以后执行mysql_reset_connection重新初始化连接资源

## 缓存
连接建立后就可以执行select语句了，他会先查询缓存，之前执行的语句值会以 key-val 的形式存在内存中，但是发生update语句后就会被清除

如果频繁插入这样就会很耗费性能，除非这个表经常查询，很少更新，否则建议将参数 query_cache_type 设置成 DEMAN 关闭缓存查询

缓存查询这种事可以交给redis做，所以msyql8中直接将这一块删掉了
 
## 分析器、优化器
分析器是编译sql，其实这步可以在程序中做，少用动态sql，多用已经编译好的sql，提高性能

就像编译原理一样，优化器是不可靠的，尽量把sql写好，别指望优化器做什么

## 执行器
前面都做完了就开始执行，首先要判断一下有没有执行权限，然后调用引擎，返回执行的结果

# 存储层
存储层借助于存储引擎实现，mysql采用插件的方式使用存储引擎，主流的引擎有 InnerDB、MyISAM、Memory等，5.5.5版本以后使用InnerDB作为默认的存储引擎

# update
select好说，就是上面server执行的那些步骤，但是update可不一般

我们对update的期望不仅仅是更新，还要记录下日志便于出错回滚

    update T set c=c+1 where ID=2;

这个语句一旦执行，和T表相关的缓存全部失效，所以不建议使用缓存

同时还要记录两个日志，redo log 和 binlog 

## redo log
当更新时，要先查找B+树(如果你用到索引的话)，再查找磁盘位置，更新磁盘，这是非常耗时的，如果在一个时间内并发量特别大，就崩了


linux写入文件时，可能会先放在内存中，等时机到了再写入磁盘，mysql也用了这个思路，先记录redo log，再更新在内存中，等不忙了再写入磁盘，即WAL技术，Write-Ahead Logging，分布式系统中也可以利用WAL实现宽松一致性

InnerDB的redo log是固定大小的，如果配置一组为4个文件，每个文件大小是1G，总共就可以记录4G的操作

![](imgs/2.png)

write pos指向已经写入磁盘的操作，check point是最新的操作，两者之间的绿色就是已经更新但还没写入磁盘

有了redo log，对内存的操作都不会丢失，就算服务挂了，内存cache数据全部丢失，还能用redo log恢复写入

## binlog
redo log是InnerDB的功能，而MySQL server层有一个binlog功能，redo log是将高并发的更新变成批处理作业，而binlog是用于记录日志，做记录回滚，在分布式系统中，也可以用binlog远程备份实现mastr节点容错

因为最早只有MySQL server，InnerDB是插件形式存在，所以各自提供log，否则可以把两种log整合在一起

binlog是逻辑日志，记录每个语句的原始逻辑，并且使用追加写，不会覆盖以前的日志

通常数据库会一周一备份或者每天备份，如果想回退到某个时间点A的状态，可以先找到A之前的备份，再执行备份到A之间的binlog

## 总结

一个update执行的完整流程如下

![](imgs/3.png)


整个过程分为prepare和commit两个阶段，因为无论redo log还是binlog先完成，中间宕机，重新启动服务后都会有错误，他们必须是一个事务操作

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失

sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

