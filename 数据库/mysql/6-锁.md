根据加锁的范围，MySQL中的锁主要分为全局锁、表锁、行锁

# 全局锁
全局锁把整个库都加了锁，阻塞所有的增删改、表结构修改操作，一般用于做全库逻辑备份

# 表锁
表锁也是粒度很大的锁，一般用于修改表结构

# 行锁
更新数据时常用到行锁，InnerDB支持行锁，MyISAM并不支持

在InnerDB事务中，行锁是在需要的时候才加上的，但并不需要时并不立即释放，而是等到事务结束后释放，即两段锁协议

事务用到哪行，就去锁哪行，等到事务提交后再解锁，如果事务略长，尽可能后更新锁冲突大的表

如果顾客A在电影院B买电影票，简化后需要一下业务操作

1. 从顾客A扣钱
2. 给影院B账余额加钱
3. 记录日志

其中同时很多人订票，影院账户最容易冲突，所以将更新影院账户操作放在最后，减少了锁等待，提高了并发性

# 死锁
存在锁，存在并发，就一定会产生死锁，MySQL解决死锁有两种办法，

1. 等待足够长事件无法继续执行，回滚重新执行，等待事件太长影响用户体验
2. 发起死锁检测，检测并发的线程是否产生死锁竞争，但是1000个并发同时检测就要10w，太耗费性能了

所以要从死锁本身去解决，可以添加中间层，对同一行的并发竞争排队，减少并发

或是将一行变为多个逻辑行，减少锁冲突

比如一个人的账户可以记成十行，账户余额就是十行加起来的结果

