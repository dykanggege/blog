# MySQL整体架构

## 逻辑架构
![](imgs/1.png)

1.  线程/连接处理器：连接处理、授权认证、安全等等
2.  解析器/缓存/优化器：查询解析、优化、缓存、内置函数等，以及其他的跨存储引擎的功能，都在此处实现
3.  引擎：负责数据的存储和提取，事务，服务器通过固定的API和引擎通信

## 锁
用锁实现对并发访问的控制，主要分为读锁和写锁，多个线程可以共享读锁，但是一旦上了写锁，就会阻塞其他所有的读写锁

锁的粒度又分为：表锁、行锁，锁定的粒度越小，并发程度越高，但锁的机制越复杂，总的来说，还是行锁更合适

## 事务
事务要保证一下特性：
1. 原子性：要么不执行，要么全部执行
2. 一致性：必须是从一个状态到另一个状态的转换，不存在转换一半
3. 隔离性：在一个事务完全执行（提交）之前，对其他事务是不可见的
4. 持久性：一旦事务完成，则是永久存在的

### 隔离级别
隔离性远远比定描述的复杂


# InnerDB

## 锁
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般（一个表可能有多个页面，页面包含了行，但是不确定包含多少行）

### 悲观锁
在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。

如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。

如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。

其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

### 乐观锁
在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。




## 索引
索引: 是与表或视图关联的磁盘上的结构，可以加快从表或视图中检索行的速度。

主键索引：表中行生成的索引。这些索引在一个结构（B 树，一个叶子三节点）中，将主键和存储文件的行匹配起来，通过检索主键在树中位置找到存储的行，同时写入就需要写入内容和索引

其他索引：在innerDB中，其他索引是通过和主键索引关联起来，通过其他索引找到主键索引，再去找到存储内容的行。同样写入时要先存储数据，再存储主键和其他的索引健，太多的索引提升了读性能，但是会导致写删该性能下降


创建索引：CREATE INDEX s2 ON s1(id)  

PRIMARY, INDEX, UNIQUE 这3种是一类
PRIMARY 主键。 就是 唯一 且 不能为空。
INDEX 索引，普通的
UNIQUE 唯一索引。 不允许有重复
FULLTEXT 是全文索引，用于在一篇文章中，检索文本信息的

## 联合索引、唯一索引
where a=?,b=?,c=? 更适合对a、b、c创建联合索引

唯一索引就是对但列创建的索引