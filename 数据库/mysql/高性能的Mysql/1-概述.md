# MySQL整体架构

## 逻辑架构
![](imgs/1.png)

1.  线程/连接处理器：连接处理、授权认证、安全等等
2.  解析器/缓存/优化器：查询解析、优化、缓存、内置函数等，以及其他的跨存储引擎的功能，都在此处实现
3.  引擎：负责数据的存储和提取，事务，服务器通过固定的API和引擎通信

## 锁
用锁实现对并发访问的控制，主要分为**读锁和写锁，也称为共享锁和排它锁**，多个线程可以共享读锁，但是一旦上了写锁，就会阻塞其他所有的读写锁

锁的粒度又分为：**表锁、行锁、页锁**、锁定的粒度越小，并发程度越高，但锁的机制越复杂，锁粒度越大，并发程度越低，但是性能较好。总的来说，还是行锁更合适

### 表锁
表锁会锁定整张表，读的时候可以并发读，一旦发生写操作，会让整个表锁住，排斥其他所有操作，而且写锁可能会插入到读锁前面。

### 行锁
行锁最大程度实现了并发，但是锁机制复杂，性能不高，InnerDB实现了行锁

### 悲观锁
在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。

如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。

如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。

其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

### 乐观锁
在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

悲观锁和乐观锁是通过系统版本号实现了MVCC的

## 事务
事务要保证一下特性（ACID）：
1. 原子性：要么不执行，要么全部执行
2. 一致性：必须是从一个状态到另一个状态的转换，不存在转换一半
3. 隔离性：在一个事务完全执行（提交）之前，对其他事务是不可见的
4. 持久性：一旦事务完成，则是永久存在的

mysql中的事务采用自动提交机制，如果不是显式开启事务，则每个语句都会作为一个事务提交

注意，mysql的事务是由下层引擎实现的，所以在一个事务中采用多个引擎是错误的

## 隔离级别
### 未提交读 read uncommitted
在事务中的修改，即使没有提交，对其他事务也是可见的。

事务可以读取未提交的数据，也被称为**脏读**

### 提交读 read committed
大多数据库默认的隔离级别都是READ COMMITTED（但是Mysql不是。。。）

一个事务在提交前，所做的修改是其他事务不可见的，又被称为不可重复读

### 可重复读 readable read
该级别保证了在同一个事务中多次读取同样的记录结果是一样的

可重复读是事务A将自己读到的数据加锁，这样其他事务B就无法修改锁住的记录了，但是B可能会插入新记录，这样A在第二次读时，多读取到一条新纪录，这就是**幻读**

**可重复读是Mysql的默认隔离级别**

### 可串行化
他是最高的隔离级别，要求所有事务必须串行执行，这对数据一致性要求很高且并发不高的情况下适用

## 死锁
两个或多个事务相互占据并请求对方的资源

数据库实现了各种死锁的检测和死锁超时机制。**InnerDB实现的是，检测到死锁，将持有行数最少的事务回滚**


# InnerDB
- InnerDB是mysql的默认引擎，主要用来处理大量短事务
- InnerDB默认采用可重复读(可能出现幻读的那种)，并采用间隙锁防止欢读
- 


# MyISAM
- 支持压缩表，如果表导入数据就不再修改，适合这个


## 索引
索引: 是与表或视图关联的磁盘上的结构，可以加快从表或视图中检索行的速度。

主键索引：表中行生成的索引。这些索引在一个结构（B 树，一个叶子三节点）中，将主键和存储文件的行匹配起来，通过检索主键在树中位置找到存储的行，同时写入就需要写入内容和索引

其他索引：在innerDB中，其他索引是通过和主键索引关联起来，通过其他索引找到主键索引，再去找到存储内容的行。同样写入时要先存储数据，再存储主键和其他的索引健，太多的索引提升了读性能，但是会导致写删该性能下降


创建索引：CREATE INDEX s2 ON s1(id)  

PRIMARY, INDEX, UNIQUE 这3种是一类
PRIMARY 主键。 就是 唯一 且 不能为空。
INDEX 索引，普通的
UNIQUE 唯一索引。 不允许有重复
FULLTEXT 是全文索引，用于在一篇文章中，检索文本信息的

## 联合索引、唯一索引
where a=?,b=?,c=? 更适合对a、b、c创建联合索引

唯一索引就是对但列创建的索引