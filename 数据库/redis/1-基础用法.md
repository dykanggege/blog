# 特性
1. 速度快：用的是内存速度当然快，使用单线程，因为相信速度够快，所以不需要并发浪费性能
2. 断电数据不丢失：停止服务时，会将所有数据写入到文件中，下次启动再读取出来
3. 多种数据结构：不止key-val，五大数据结构是基于字符串的，还有一些衍生的具有针对性的高效数据结构
4. 功能丰富：支持订阅、事务、主从复制、LRU回收键等

# 启动
- redis-server：启动redis服务
    - redis-server --p 6380 在其他端口启动一个redis服务
    - redis-server /etc/redis/6380.conf 通过配置文件启动，因为redis是单线程模型，所以我们可能需要一个项目中用到多个redis，或者每个项目都需要一个reids，这时候他们就需要配置不同的端口和其他信息，并通过配置文件启动
- redis-cli：进入redis交互端，默认进入本机，可以用 redis-clie -h 127.0.0.1 -p 6379

# 配置文件
通常会有一个默认的配置文件在/etc/redis下，我们在启动多个redis时要定制自己的配置文件，可以把配置文件和数据放在自己的项目中

可配置的内容很多，从启动redis来说，只需要知道下面这几个就足够了

    #修改daemonize为yes，即默认以后台程序方式运行（还记得前面手动使用&号强制后台运行吗）。
    daemonize no
    #可修改默认监听端口
    port 6379
    #修改生成默认日志文件位置
    logfile "/home/futeng/logs/redis.log"
    #配置持久化文件存放位置
    dir /home/futeng/data/redisData

# 单线程
redis是单线程，也就是说所有任务都是顺序执行的，不存在并发，同时它也是非阻塞IO

# 数据类型
## key
redis的键是二进制安全的，可以使用任何格式的二进制序列作为键，但是你应当遵守一些开发规则

1. 不要使用太大的键，会浪费内存和查找性能，如果必须要，可以使用SHA1(原值)作为键
2. 不要用太短的键，你的键名设计应当具有命名空间，遵守某种规则
3. 键的最大长度是512M

关于键还支持很多额外的功能，下面列举部分

1. 对键的增删改查
2. 设定键值的生命周期，可以很好的用在session上
    1. 过期时间可以设置为秒或毫秒
    2. 过期信息会被复制和持久到磁盘，即使redis停止，时间也会计算
3. 判断键的值类型

## string
作为一个key-val内存数据库，这里的val就是最基本的字符串，他没有大小范围

redis对字符串主要有一下几个操作

1. 基本的字符串存取、批量存取、范围读取
2. 计数操作，原子性增长，因为redis是单线程模型，所以不会出现并发问题

适合存储session、主键、唯一个数等类型的值

## list
列表对应两种方式实现，一种是压缩列表，一种双向循环链表

- 保存单个数据都小于64字节
- 列表中数据小于512个

采用压缩列表，即64字节数组实现，我觉得没太大意义，超出之后还是用链表实现的

提供了插入头部尾部的功能，可以模拟栈或队列的功能，除此之外提供了一下的功能

1. 查找下表范围内范围内的数据，尽可能从头部或尾部查询，毕竟是个链表，如果查找范围在链表中部，还是很浪费时间的
2. 截取链表的长度，或者说叫限制容量，还有其他链表可以完成的操作
3. 生产者-消费者模型，提供阻塞的push和pop，并设定timeout

可以用于消息队列，或表现图

## hash
key-hashmap

1. 一个redis哈希值可以存储约40亿个key-val对
2. 支持所有基本的map操作

当数据量较小的时候，采用压缩列表方式实现，这时候遍历数组性能比map好，fasthttp中也是这样做的

- 保存单个数据都小于64字节
- 列表中数据小于512个

数据大时，采用散列表，当hash冲突时采用链表法解决，有意思的是hash的扩容和缩容

特别适合做缓存

### 扩容与收缩
装载因子很有意思，如果太小，会浪费内存，如果太大，性能会下降

- redis当装载因子是1的时候才扩容，变为2倍，更注重内存占用
- 装载因子变为0.1时，会收缩，缩小为字典中数据个数大约2倍

当扩容或收缩时，采用渐进式扩容，保留旧map和新map

- 插入值，直接放入new map
- 查找值，先在 old map 中查询，查找到了将其迁移到 new map 中，未查找到也会带一个数据到 new map 中

增量扩容避免大量数据一次性迁移导致服务卡顿

## set
可以向一个集合中插入多个元素值，返回值是无序的

set和hash很相似，set不提供有序存储，但支持并集、交集、随机抽取元素等操作

1. 支持所有set基本操作
2. 随机返回一个或多个元素，可以选择是否移除
3. 对两个set做集合操作

当数据都是整数，且存储元素小于512时，以数组方式存储，大数据集采用散列表存储

## sorted set
hash、set、sorted set 他们都不允许重复的成员

sorted set中插入值会有一个权重，采用跳表的方式维持，类似B+树的结构，但会额外占据一倍内存

