快速排序是目前最常用的排序算法，稳定时时间复杂度在 nlogn 和 n^2 之间，相较于其他排序，无论是平均时间复杂度还是最坏时间复杂度都是可以接受的

其思想如下，先选取一个主元，将所有比他大的放在右边(假设为left组)，比他小的放在左边(假设为right组)。再去left组和right组重复这样的操作(递归调用)，直到组的大小变为1，就完成了排序。他也包含了分治的思想

用两个指针控制，查找到比主元大的值后，调用右边的指针，查到一个比主元小的值，交换位置，然后这样遍历下去，达到比主元小的放在左边，比主元大的放在右边的效果。虽然是递归调用，但是等同于每次遍历数组，遍历的次数等于划分数组的次数。

最好的情况下选的主元在排序之后，刚好是中位数，左右组的长度相同，则递归次数为 logn ，则所以时间复杂度是 nlogn 

最坏的情况是选择的主元在排序之后都是最左边的数，则第m次要扫描n-m个数，而共需扫描n-1次，时间复杂度大概是 O(n^2) 

# 选主元
排序速度的快慢很大程度受到了主元选择的影响，但是我们无法预料到组排序之后主元可能出现的位置，所以对主元有两种选法

如果用随机数在数组下标允许范围内选择，那么随机数的产生也会带来性能的损耗，而且并不能帮助让主元达到一个最好的位置，这样只是一个毫无作用的性能浪费

如果使用最左边的数作为主元，可能会有已经是排序好的数组，那么每次分割数组都是主元右边的数组，分割了n-1次，同理可用于右边

目前来说，使用中间的元素作为数组较好

```
func QuickSort(arr []int)  {
    //选取主元
	base := media(arr)
	l := len(arr)

	if l < 4{
		return
	}
	
    left,right := 1,l-2

	for {
		for arr[left] < base{
			left++
		}
		for arr[right] > base{
			right--
		}
		if left < right{
			arr[left],arr[right] = arr[right],arr[left]
		}else{
			break
		}
	}
    
	QuickSort(arr[0:left])
	QuickSort(arr[left:l])
}

func media(arr []int) int {
	l := len(arr)
	if l < 2{
		return 0
	}
	l--

    //设置左右哨兵
	m := l/2
	if arr[0] > arr[m] {
		arr[0],arr[m] = arr[m],arr[0]
	}
	if arr[m] > arr[l] {
		arr[m],arr[l] = arr[l],arr[m]
	}
	if arr[0] > arr[m] {
		arr[0],arr[m] = arr[m],arr[0]
	}

    //将主元放在右边，避免中间出现和主元相等的元素，复杂情况
	arr[m],arr[l-1] = arr[l-1],arr[m]
	return arr[l-1]
}

```


# 栈的性能
由于快速排序使用了递归，而递归调用不仅消耗栈内存，在排序数量较小时，栈的push、pop操作带来的性能浪费会导致快排还不如普通排序，所以我们可以设置一个阀值，当要排序的数量小于阀值时，使用冒泡排序

