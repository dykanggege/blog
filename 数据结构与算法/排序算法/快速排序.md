快速排序是目前最常用的排序算法，稳定时时间复杂度在 nlogn 和 n^2 之间，相较于其他排序，无论是平均时间复杂度还是最坏时间复杂度都是可以接受的

其思想如下，先选取一个主元，将所有比他大的放在右边(假设为left组)，比他小的放在左边(假设为right组)。再去left组和right组重复这样的操作(递归调用)，直到组的大小变为1，就完成了排序。他也包含了分治的思想

最好的情况下选的主元在排序之后，刚好是中位数，左右组的长度相同，则递归次数为 logn ，由于每次都需要遍历数组去调整左右组，则所以时间复杂度是 nlogn 

最坏的情况是选择的主元在排序之后都是最左边的数，则第m次要扫描n-m个数，而共需扫描n-1次，时间复杂度大概是 O(n^2) 

# 选主元
排序速度的快慢很大程度受到了主元选择的影响，但是我们无法预料到组排序之后主元可能出现的位置，所以对主元有两种选法

如果用随机数在数组下标允许范围内选择，那么随机数的产生也会带来性能的损耗，而且并不能帮助让主元达到一个最好的位置，这样只是一个毫无作用的性能浪费

目前最常用的是使用中位数作为主元

# 栈的性能
由于快速排序使用了递归，而递归调用不仅消耗栈内存，在排序数量较小时，栈的push、pop操作带来的性能浪费会导致快排还不如普通排序，所以我们可以设置一个阀值，当要排序的数量小于阀值时，使用冒泡排序

