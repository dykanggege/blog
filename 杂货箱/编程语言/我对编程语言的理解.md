编程语言在编程领域中是一个复杂的定位。说它不重要吧，他承担了上层应用和操作系统(硬件)、计网、数据结构等之间的联系，说它重要，似乎每个编程语言都没那么重要，对于程序员来说它只是一个工具。

从早期的机器语言到汇编语言，再由汇编到高级语言，甚至发展到现在各种不同范式的高级语言。每一种流行的语言都不是凭空出现的，他们是随着硬件发展、需求变化、软件成本等等因素共同推动的

也许有一天编程语言会成为像汇编语言一样的底层，中间会有其他的转换器，讲更接近人类的表述转换为很好的代码。这种可能不是虚无的，只要这个需求存在，就可能会出现。同时也不必惊恐，新的事物不是凭空诞生的，而是在多种因素的综合下缓慢推动的，所以在代码之外应该多关注其他领域，顺应趋势的变化去学习，当新的事物诞生后就也不会慌张了，就像docker之于运维。

# 语言设计的艺术
到现在已经有上千种编程语言了，一个语言是否被使用取决于很多因素，大概有下面这些
- 硬件与软件：当人力成本高于硬件成本时，编写可读可维护的代码的要求就高于性能要求，像这样的例子还有很多。许多软件的出发点是为了盈利，所以不能忽略硬件和人力的成本问题。
- 特殊用途：现在很难说有一种在所有领域通吃的语言了，各个语言都有自己的杀手级特性，一些语言的设计初衷就是为了解决在特定领域下的问题。个人觉得，以后这种趋势会更加明显，程序员再也不能标榜自己是“java程序员”，“python程序员”，而是根据需求的变换选择在这个场景下更合适的语言，就像python对于爬虫，golang对于高并发
- 表达力：用这种语言清楚简洁的把自己的想法表达出来的能力，且代码清晰、紧凑易于维护。说表达力就不得不说语法糖和编程范式，如果语法糖简洁干净，表达力会很好，如果抽象级别好，表达力会很好，如果很好的支持多种编程范式，表达力力会很好，如果是java，设计模式就大行其道，违背了设计模式的初衷，嗯...
- 杀手级特性：就像rust，语法丑陋，语法糖也不甜，上手难度还高，但保证了内存的绝对安全，很香。golang，没有什么新的，就是提供了一些好用的语法糖，甚至还是过程式编程，但是goroutine，真香。
- 个人偏好：不说了...有些人总是试图将一门编程语言强行应用在所有领域，也有些人不喜欢各种语言的书写方式，比如说python的缩进，比如说王垠对rust的吐槽
- 简单、易于实现、标准化、强大的编译器、开源等等其他因素，除了技术之外还有商业因素

总之，没有最好的的语言，只有最合适的，大多时是根据业务需求权衡利弊下挑选语言

# 编程范式
语言的设计和思想是分不开的，将思想具体话就是一种种的编程范式。编程语言大概可以分为两大家族，**说明式、命令式**，往下又可以细分为很多编程范式。

- 说明式面向的是人的表达，其语法更接近数理逻辑思维，接近人的思维，但是有尽可能给予计算机细节来实现算法。主要代表是list以及其他不出名的方言
- 命令式就是告诉计算机如何运行，写下的是一条条指令，现在主流语言都是命令式的

编程范式就有更多了

- 面向过程编程：c就是一个典型的面向过程编程，将一个任务分解多个子任务，再将子任务分解，就像从树根向上逐渐长出更多的叶子。这种方式编程较简单，但写出的代码很容易复用性维护性不强，需要高深的编程功力
- OOP 面向对象编程：其目的就编写可维护、可扩展、可复用的代码，本质是将函数依赖的变量维护在对象中，减少外部影响。oop倾向于先制造每个树叶，再组合枝干，最后总和到树根，和面向过程相反。
- FP 函数式编程：它的风格类似数理公式，更接近人的思维方式，由于函数的状态是固定的，所以函数式编程不会带来任何副作用，且接近数理思维，但难度较高。主要适用于数据处理
- 元编程：编译器用于将高级语言翻译为c或汇编语言，如果一门编程语言可以创造新的语法，并能翻译为该语言，就能算作元编程。ruby可以在程序运行中改变元信息(可以简单理解为源代码)，因此可以动态的适应条件变化。元编程能很好的用于DSL(特定问题领域)，将复杂的算法抽象为语法糖，交给其他人使用，这是一种高级的抽象。

上面的四中编程范式是最基本的，最能在编程语言中体现的范式。我们很难将一门语言归类于某个编程范式，只能说一门语言对某个范式的支持度如何。由于范式之间存在冲突，很难有语言能将多种范式平衡在其中，而是选择更好的支持一种范式。除了C++(巨坑)

其他的还有一些编程范式，他们都体现了计算机发展中诞生的思想。这些编程范式直接体现在语言中，或间接的由框架、架构等体现出

## 泛型编程 
很多程序的本质都是数据结构+算法，泛型的作用就是将数据结构和算法分离，使得算法可以在多个地方复用，无需关心数据结构。最常见的是java中的泛型，c++中的STL编程

除了语言中直接支持的泛型，业务上也是如此，其核心思想就是，抽离变化的，留下不变的

## AOP切面编程
切面编程一般是对OOP的一个补充，虽然函数式语言或过程式语言中也有切面，但他们较容易实现

而OOP语言遵循抽象分解原则：单一化、正交化。即每个模块职责确定且专一，模块之间相互独立，高内聚低耦合

这就造成了OOP切面编程不是一件容易的事，如果深入到每个模块中做横向切面，会造成耦合严重且代码冗余。只能在模块之间做横向切面，这就强调对业务功能的拆解和模块的划分，在不合理的模块中是无法做切面的

由于OOP是沿着继承树纵向发展，AOP可以在两个继承中间做一个中间层，作为切面层，可以添加切面的功能。对OOP的切面，尤其要注意接入点和切入点，一个强调接入的方式，一个强调切入的面

OOP是纵向方面的重用，而AOP是横向方面的重用，对OOP做了一个很好的补充。这种重用方式对OOP程序员的抽象和分解能力提出了更高的要求，同时也强调了对业务做横向拆分和纵向拆分的重要性。

## 事件驱动
	
	有事你喊我，没事别烦我！
	
事件驱动虽然是个单一的概念，但是在实现中通常会和异步、回调、依赖注入等概念联系起来，因为单单事件驱动是没有太大意义的，下面还会顺带解释这些概念

与事件驱动对应的是流式驱动。如果你喜欢看一个杂志，杂志每周五更新。如果你每周五都去报亭找一遍所有杂志，看看你更新的杂志有没有到货，这是流式驱动。如果你定了这个杂志，每次一更新就有人给你送上门，这是事件驱动。且不说事件驱动的底层，在这种发布-订阅者模式中，事件驱动的表达力更强

事件驱动分为两类。

- 有些是原生事件，例如你在正在执行的linux进程中按下ctrl+c，linux会给这个进程发一个终止信号，如果它继承了父进程的默认处理程序且没有改写，就出调用对应的处理函数，终止进程
- 语义事件和自定义事件，他们都是对底层事件的包装或者自己用代码实现监控的事件

事件驱动只是一个概念，更重要的是基于事件驱动产生的编程思想

事件驱动使得调用者不再依赖于被调用者，将两者从代码上解耦，例如下面js代码

	document.getElementById('id').addEventListener('click',func)
	
func是被调用者，他现在是灵活可变的，这就是控制翻转。平时我们写代码都是封装函数调用底层的API，现在是给底层的API传入我们封装的函数，底层调用高层了，从调用上实现了底层和高层的解耦，似乎和观察者模式的想法有有点像。

而在js中，func作为一个回调函数，是异步非阻塞的，注册后并不立即调用，而是等待事件发生，又将两者从时间上解耦了

我们可以将高层处理注入底层，同样可以将高层对底层的依赖注入，这就是spring里最出名的IOC

通常我们编写上层模块要依赖于下层模块，现在下层模块是可变的，不再强制依赖，而是通过注入方式，实现了他们之间的解耦。

除了上面说的，还有并发编程、安全编程等范式就不一一介绍了

# 综上
我们扯了这么多思想还有范式，其根本目的就是想说，在我们评估或学习一个编程语言时，对于那些通用特性：变量类型、逻辑控制等，并不需要过于关心。这些就算语法糖不够甜，都是可以忍受的。我们真正应该关心的是它对不同的编程范式的支持度，还有它的杀手级特性

如果你是一个新手，随便选一门简单的语言开始学就好，反正你以后还要掌握很多很多种语言。如果你已经有了编程经验，更应该注重通过编程语言学习编程范式，和杀手级特性的原理(杀手级特性往往代表这个语言最有诱惑力的地方，是他的精华)，而不是陷入语法细节。


    int substr(str,sub string) int{
        if str == "" || sub == ""{
            return -1
        }
        
        lstr,lsub := len(str),len(sub)

        for i := 0; i < lstr; i++{
            if lstr - i < lsub{
                return -1
            }
            for j,k :=0,i; j < lsub && k < lstr; j++{
                if sub[j] == str[k]{
                    k++
                }else{
                    break
                }
            }
        }
    }