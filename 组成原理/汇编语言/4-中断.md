目前为止我们已经知道CPU具有以下的能力

- 传输数据
- 运算
- 条件跳转

任何一个通用的内存都具有一种能力：在执行完成当前指令后检测从CPU内部或外部发过来的一种信号，并立即对信号做出反应，我们将这种信号成为中断信息

# 内中断
对8086CPU，有下面情景发生时触发中断

- 除法错误 0
- 单步执行 1 
- 执行into 4
- 执行int n

触发中断时CPU会提供大小为1字节的中断变量，可以表示256种可能

用中断变量在中断向量表中查询，就能得到对应的处理程序地址

在8086中，中断向量表内存地址为0000:0000-0000:03FF，每个表项占两字节，高地址存放段地址，低地址存放偏移地址

当发生中断时，会有中断硬件自动完成下面步骤

1. 从中断信息处获取中断类型码
2. 标志寄存器入栈 pushf
3. 设置标志寄存器8-TF，9-IF值为0 TF=0,IF=0
4. CS、IP入栈 push CS,push IP
3. 中断类型码\*4+中断类型码\*4+2，设置IP、CS地址 (IP)=(N\*4),(CS)=(N\*4+2)

中断处理程序和子程序类型

1. 保存用到的寄存器
2. 处理中断
3. 恢复寄存器
4. iret == pop IP,pop CS,popf


## int

    int n ;手动触发中断

从本质上来看，int和call指令相同，都是调用一个子程序

# 端口
前面说过了，计算机本质就是计算设备+IO设备，除CPU外的设备都可看做IO设备

指令并没有分别为不同的设备提供不同的指令，而是看做一个大的内存地址空间，将不同的空间地址划分给不同的设备，从而访问设备。这种从本质上高度抽象的思想体现在软件的方方面面，尤其是linux设计中(当然设备想不遵循这些，提供定制化的功能)

像内存、显存等都是由芯片控制的，使用地址访问芯片会自动解码，但有些必须借助其芯片寄存器访问，从CPU角度将这些寄存器统一编址，从而建立了一个统一的端口地址空间，同时将端口空间映射到内存地址空间上，每个端口在地址空间都有个地址

这样的统一接口带来了解耦，兼容，简化了指令集，但也限制了硬件的演化设计

对端口的读写不能用mov、push、pop等内存读写命令，使用in、out操作，虽指令不同，但还是用内存地址操作

    in al 60h ;读入字节到al中
    out 60h,al ;写出字节



# 外中断
外设的输入并不直接送入内存和CPU，而是放入外设端口中，并发出中断，等待程序从端口取出并处理

外设的中断分为可屏蔽和不可屏蔽，一般来说都是可屏蔽中断

CPU是否相应可屏蔽中断取决于IF的值，如果IF=1，CPU执行完当前指令后相应中断，如果IF=0，则不响应屏蔽中断

- sti 设置IF=1
- cli 设置IF=0