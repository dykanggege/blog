# 变量
$直接声明，无类型
## 作用域
分为局部和全局，无法跨作用域使用（变量声明和使用放在一起，局部作用域内咋知道这是声明还是用了其他作用域）

全局作用域和js类似，是整个文件作用域

```
global $x,$y //使用全局作用域中的参数
//PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。
//$GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];

function func($y){ //参数作用域
    static $x; //静态作用域，函数调用完成后变量不会被销毁，下次调用还是上次调用的值
}
```

## EOF
字符串模板

```
$name="runoob";
$a= <<<EOF
    "abc"$name
    "123"
EOF;
// 结束需要独立一行且前后不能空格
// 开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。
```

## 数据类型
1. 字符串：$str = 'str'.'str' 使用 . 连接字符串
2. 数组：$cars=array("Volvo","BMW","Toyota");，var_dump($cars);返回数组类型和值，count($arr)获取数组长度
```
//数组和字典可以混用
$age=array("Peter"=>"35","Ben"=>"37","Joe"=>"43");

or:

$age['Peter']="35";
$age['Ben']="37";
$age['Joe']="43";
//遍历数组
foreach ($array as $value)
{
    要执行代码;
}
//遍历字典
foreach($age as $x=>$x_value)
{
    echo "Key=" . $x . ", Value=" . $x_value;
    echo "<br>";
}
```
3. 对象：
```
class Car
{
  var $color;
  function __construct($color="green") {
    $this->color = $color;
  }
  function what_color() {
    return $this->color;
  }
}
```

4. NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。

5. 定义常量：bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )
    - define("GREETING", "欢迎访问 Runoob.com");
    - 常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用，即使在函数中定义


# 命名空间
## 定义命名空间
// 定义代码在 'MyProject' 命名空间中  
namespace MyProject; 

在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。

```
<html>
<?php
namespace MyProject; // 命名空间前出现了“<html>” 会致命错误 -　命名空间必须是程序脚本的第一条语句
?>
```

```
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace MyProject {
    //建议这样写
}
```

//一旦定义命名空间，全局空间也需要放在无名空间下
namespace{}

namespace MyProject\Sub\Level;  //声明分层次的单个命名空间

## 引用
```
/* 非限定名称 */
foo(); // 解析为函数 Foo\Bar\foo
foo::staticmethod(); // 解析为类 Foo\Bar\foo ，方法为 staticmethod
echo FOO; // 解析为常量 Foo\Bar\FOO

/* 限定名称 */
subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo
subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo,
                                  // 以及类的方法 staticmethod
echo subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO
                                  
/* 完全限定名称 */
\Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo
\Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod
echo \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO

$a = \strlen('hi'); // 调用全局函数strlen
$b = \INI_ALL; // 访问全局常量 INI_ALL
$c = new \Exception('error'); // 实例化全局类 Exception
```

**对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。**



## 导入
```
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;
```

## 动态语言特征
动态语言是啥，是动态解释，和java的编译解释不同，动态语言只对命名空间进行编译，其他都不管，所以无法做类型检查，甚至通过字符串作为变量名使用
```
$a = 'classname';
$obj = new $a; // prints classname::__construct
$b = 'funcname';
$b(); // prints funcname
echo constant('constname'), "\n"; // prints global

/* 如果使用双引号，使用方法为 "\\namespacename\\classname"*/
$a = '\namespacename\classname';
$obj = new $a; // 输出 namespacename\classname::__construct
$a = 'namespacename\classname';
$obj = new $a; // 输出 namespacename\classname::__construct
$b = 'namespacename\funcname';
$b(); // 输出 namespacename\funcname
$b = '\namespacename\funcname';
$b(); // 输出 namespacename\funcname
echo constant('\namespacename\constname'), "\n"; // 输出 namespaced
echo constant('namespacename\constname'), "\n"; // 输出 namespaced
```



# 类
```
class Site {
  /* 成员变量 */
  /*var 默认是 public*/
  var $url;
  var $title;
  public $public = 'Public';
  protected $protected = 'Protected';
  private $private = 'Private';

  //构造函数
  function __construct( $par1, $par2 ) {
    $this->url = $par1;
    $this->title = $par2;
  }
  //析构函数
  function __destruct() {
       print "销毁 " . $this->name . "\n";
  }

  /* 成员函数，默认是public*/
  public function setUrl($par){
     $this->url = $par;
  }
  
  function getUrl(){
     echo $this->url . PHP_EOL;
  }
  
  function setTitle($par){
     $this->title = $par;
  }
  
  function getTitle(){
     echo $this->title . PHP_EOL;
  }
}
//变量 $this 代表自身的对象。
//PHP_EOL 为换行符。

$runoob = new Site;
$taobao = new Site;
$google = new Site;

// 调用成员函数，设置标题和URL 
$runoob->setTitle( "菜鸟教程" ); 
$runoob->setUrl( 'www.runoob.com' ); 

// 调用成员函数，获取标题和URL 
$runoob->getTitle(); 
$runoob->getUrl(); 

//继承，支持方法重写
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}
```

- PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。
- 声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。
- PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。


```
class BaseClass {
   public function test() {
       echo "BaseClass::test() called" . PHP_EOL;
   }
   
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called"  . PHP_EOL;
   }
}

class ChildClass extends BaseClass {
   public function moreTesting() {
       echo "ChildClass::moreTesting() called"  . PHP_EOL;
   }
}
// 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()
```





# 接口
```
// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}
```