javascript是一门饱受争议的语言，像C、Go这样的编程语言编译器实现严格按照约定，其语法就没有模棱两可的概念，而js由浏览器沙盒执行，各个平台实现有所差异，且语法上也有些不合理的地方，所以让js看起来有些乱，很脏的感觉

所幸有ES6等新的标准不断修复前面的问题，我们按照一个合理的眼光，在不考虑兼容性，最好执行环境下，审视这门语言

假设开启"use strict"且代码会经过打包工具转换，在最优情况下使用js

# 分号
强制：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要

# 声明
ES5及之前使用var声明，有太多弊病，建议开启"use strict"，并使用let

变量必须用let声明，他的作用域存在于任何{}中，不是window属性，看起来就像一个正常语言的声明

现在的问题在于弱类型，你无法知道一个变量生命周期内会变成什么类型(typeof坑有点多)，最好的方式就是在声明后就不改变它，大部分情况下const都是最好的选择

对于函数，要明确写出函数参数所需类型，总的来说约定大于检测

# 基本类型

## undefined
- 声明但未定义，或未声明
- null==undefined，因为undefined是由null派生出来的
- undefined===undefined

## Boolean
- 直接量 true、false
- 用于逻辑判断时，除却false、''、0、null、undefined、NaN，都被视作true

## Number
- 只有浮点数，基于IEEE754，0.1+0.2=0.30..4
- parseInt()、parseFloat() 将字符串转换为数值
- Number() 将其他类型转换为数值，不应当使用其他类型做转换，只用字符串
- NaN非数值，isNaN()先尝试解析为数值，然后再判断

数值于字符串之间的转换应严格转换，不要用任何花里胡哨的坑

# 操作
## 运算
- ++--
- ~ | & ^ ! && || 
- << >> 算数右移，>>> 逻辑右移
- 不要使用 == 全部用 ===，严格判断是否相等

## 流程
- if、for、while、do-while
- for in 枚举对象属性或数组变量，枚举对象属性保证有序，枚举数组保证有序

# 函数
- 函数作为一等公民
- 函数会被提升到代码最前面，后声明的函数覆盖前面的函数
```
//不用定义返回值
//声明的参数和实际传入参数没有任何关联
function fn( param ) {
    console.log(arguments) // 这才是真正传入的参数数组
}

function f(x=1){console.log(`默认参数`)}

function f(...arr) {console.log(`可变参数`)}

```

## this
函数中的 this 指向调用函数的对象，严格模式下不会自动指向window

fn.call() 可以改变this的指向，函数就可以随便绑定对象了，很有意思

- call(obj, params)
- apply(obj, array)

## lambda

    const foo = () => 1+1 

箭头函数中的this指向是固定的，在写下函数时就被绑定了，不会改变


# 引用类型
## Object
```
// 对象初始化器（Object initialiser）或对象字面量（literal）
{ [ nameValuePair1[, nameValuePair2[, ...nameValuePairN] ] ] }

// 以构造函数形式来调用
new Object([value])

obj.name
obj.['name']
obj.[param]

for(let item in obj) { //遍历对象可枚举属性
    console.log(obj[item])
}

//设置属性的getter、setter
Object.defineProperty(book, "year", {
    get: function(){
        return this._year;
    },
    set: function(newValue){
        if (newValue > 2004) {
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});

Object.defineProperties(book,{})
```

- const copy = Object.assign(target, ...sources) 浅拷贝
- Object.keys(obj) 把obj的可枚举key作为一个数组返回
- Object.values(obj) 返回可枚举value数组

## String
- 使用Unicode字符，16位编码
- 字符串中包含转义字符，用 \ 转义转义字符
- 可以看做数组使用，通过下表访问每个字符，这个特点还不错

### 字符串模板
ES6中添加了字符串模板的功能，早就应该实现了，但提供的功能太多了，在模板中实现功能并不是明智的做法，最可怕的是只要提供了，就一定有人会这样做

    `和go类似，但是对 ${变量} 做转义
     换行没问题
    `

## Array
js的数组实在是太太太灵活了
```
const arr1 = new Array(3) 
const arr2 = new Array('nb')

arr1.length //返回长度
arr1[3] //越界访问返回undefined

arr1[3] = 1
arr1.length //4,越界赋值会自动扩充

arr1.length = 10 //强制赋值，有效
arr1[9] //undefined
```

```
arr.push(1)
arr.pop()

arr.shift()
arr.unshift()

arr.indexOf(1) //0

arr.slice(0,4) //浅拷贝

[1,2,3].forEach((v,i,arr)=>{

})

const newarr = [1,2,3].filter((v,i,arr)=>{

})

const map1 = [1,2,3,4].map(x => x * 2);

```

## 其他

### window
window是一个global对象，类似isNaN都是window的方法

### set、map