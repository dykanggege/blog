计算机执行机器代码，用字节编码低级的操作。虽然位只有 0 1 两种可能，但是足够多的位就能组合成无数的可能，用来处理数据、管理内存、读写存储设备上的数据。将他们按字节编码，就成了人类易于阅读的汇编语言。

编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码，学习高级语言到机器代码的编译，有助于我们写出更高效的程序

# 程序编码
## 机器级代码
计算机最大的特点就是抽象，抽象封装细节，只留下简单的抽象模型。对于机器级编程，也有两大抽象。

指令集体系结构就是对机器指令的抽象，用指令集代替常用的一系列指令操作。对于处理器而言，指令并不是一条条执行的，而是并行的执行多条，但是通过其他方法保证整体行为与指定的执行顺序相同

第二大抽象是，机器级使用的内存地址是虚拟地址，存储器系统提供的内存模型像是一个非常大的字节数组，通过数组下标访问地址。

再理解机器代码前，我们首先要了解一点 cpu 的内部硬件

- 程序计数器，简称 pc，给出要执行的下一条指令在内存中的地址
- 整数寄存器文件包含  16 个命名的位置，分别存储 64 位的值，这些寄存器可以存储地址或整数数据，有的寄存器保存重要的状态，有的寄存器保存临时数据，比如过程参数和局部变量，以及函数返回值
- 条件码计数器保存着最近执行的算术或逻辑指令的状态信息，他们用来实现控制或数据流中的条件变化，比如 if 和 while
- 一组向量寄存器可以放置一个或多个整数或浮点数

再了解一点内存：

- 在编程语言中无论是何种数据结构，内存中都是用连续的或不连续的内存单元中的字节表示
- 程序的内存包含：程序的可执行机器代码、操作系统需要的信息、用来管理过程调用和返回的运行时栈，以及用户分配的内存块

一条机器指令只能实现一个非常基本的操作，例如将两个数字相加，编译器必须产生这些指令序列，从而实现程序结构

**这里以 ATT 格式介绍汇编代码**

# 访问信息
一个 cpu 通常包括一组 16 个通用目的寄存器，他们的名字都以 %r 开头

## 操作数指示符
大多数指令需要一个或多个操作数，指示出执行一个操作中要使用的源数据和放置的位置。源数据可以以常数的形式给出，或者从寄存器或内存中读出，结果可以放在内存或者寄存器中。因此，操作数可以分为三种

- 立即数，用来表示常数值，以 $ + 常数值形式表示
- 寄存器，它表示某个寄存器中的内容，可以是寄存器的前 1，2，4 或 8字节作为一个操作数，我们用 ra 表示寄存器 a，用引用 R[ra] 表示它的值，这是将寄存器看作数组，用下标索引它的值
- 内存引用，它会根据计算出来的地址访问某个内存位置。因为将内存看作一个巨大的字节数组，我们用符号 Mb[Addr] 表示对存储在内存中的地址 Addr 开始的 b 字节值的引用。为了简便，我们通常省去下标 b。有多种不同的寻址模式，常用的是 Imm(rb,ri,s)，Imm 立即偏移数，rb 基址寄存器，ri 变址寄存器，s 比例因子，这里 s 必须是 1 2 4 8，基址或变址寄存器必须是 64 位寄存器，有效地址是  Imm + R[rb] + R[ri] * s。引用数组元素时，会用到这种通用形式，其他形式都是这种通用形式的特殊情况。

| 类型 | 格式 | 操作数值 | 名称 |
|:-------:|:-------:|:-------:|:-------:|
|立即数|$Imm|Imm|立即数寻址|
|寄存器|ra|R[ra]|寄存器寻址|
|存储器|Imm|M[Imm]|绝对寻址|
|存储器|(ra)|M[R[ra]]|间接寻址|
|存储器|Imm(ra)|M[Imm+R[ra]]|基址+偏移寻址|
|存储器|(ra,rb)|M[R[ra]+R[rb]]|变址寻址|
|存储器|Imm(ra,rb)|M[Imm+R[ra]+R[rb]]|变址寻址|
|存储器|(,rb,s)|M[R[rb]*s]|比例变址寻址|
|存储器|Imm(,rb,s)|M[Imm+R[rb]*s]|比例变址寻址|
|存储器|(ra,rb,s)|M[R[ra]+R[rb]*s]|比例变址寻址|
|存储器|Imm(ra,rb,s)|M[Imm+R[ra]+R[rb]*s]|比例变址寻址|

## 数据传输指令
最常用的指令是，将数据将一个位置复制到另一个位置的指令。这里介绍最简单的数据传输指令，MOV类

MOV 类由四条指令构成：movb、movw、movl、movq 这些指令执行相同的操作，但是复制不同大小的数据，MOV S,D 将 S 复制到 D



# 算数和逻辑操作

# 控制

# 过程

# 数组分配和访问

# 异数的数据结构

# 在机器级程序中将控制和数据结合起来

# 浮点代码

